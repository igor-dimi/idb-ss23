[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "IDB SS23 Solutions & Notes",
    "section": "",
    "text": "IDB SS 23 Loesungen & Notizen\nIDB SS 23 Loesungen & Notizen"
  },
  {
    "objectID": "01/blatt01.html#grundlagen-der-logik",
    "href": "01/blatt01.html#grundlagen-der-logik",
    "title": "1  Grundlagen der Relationalen Algebra",
    "section": "1.1 Grundlagen der Logik",
    "text": "1.1 Grundlagen der Logik\n\n\n\n\nWenn zwei Tiere im selben Lebensraum leben, essen sie auch das selbe.\nfalsch: \\(t_{1}\\) (Gepard) und \\(t_{9}\\) (Uganda-Grasantilope) haben den gleichen lebensraum “Regenwald” aber andere Ernaehrungen; Karnivore und bzw. Herbivore.\nerfuellbar: Jede Datenbank, die ein einziges Tier enthaelt erfuellt diese Aussage automatisch.\nFuer jedes Zootier existier ein anderes Zootier, welches entweder die selbe Nahrung isst oder im selben Lebensraum lebt. wahr\nEs existieren drei Zootiere, so dass erstes und zweites ,sowie zweites und drittes den gleichen Lebensraum teilen aber erstes und drittes nicht.\nfalsch und nicht erfuellbar: \\(l(x, y)\\) ist eine Aequivalenzrelation. Somit gilt Transitivitaet: \\(l(x, y) \\wedge l(y, z) \\rightarrow l(x, z)\\)\nEs gibt keine zwei unterschiedliche Tiere, die sowohl der gleichen Familie zugehoerig sind als auch den gleichen Lebensraum teilen.\nfalsch: \\(t_{6}\\) und \\(t_{10}\\) sind beide Sakiaffen mit dem Lebensraum Regenwald.\nerfuellbar: Jede Datenbank mit einem einzigen Element efuellt diese Aussage automatisch.\n\n\n\n\n\n\\(\\forall x\\in T \\exists y \\in T: x \\neq y\\wedge fam(x, y) \\wedge \\neg ls(x, y)\\)\n\\(\\forall x\\in T\\forall y\\in T: fam(x, y) \\wedge le(x, y) \\wedge er(x, y) \\rightarrow x = y\\)\n\\(\\forall x \\in T \\forall y\\in T: fam(x, y) \\rightarrow er(x, y)\\)"
  },
  {
    "objectID": "01/blatt01.html#relationale-algebra",
    "href": "01/blatt01.html#relationale-algebra",
    "title": "1  Grundlagen der Relationalen Algebra",
    "section": "1.2 Relationale Algebra",
    "text": "1.2 Relationale Algebra\n\nGebe die Modelle von Flugzeugen, die so heissen, wie einer aus dem Personal.\n\n\n\nModell\n\n\n\n\nQuack\n\n\n\nGebe die crew ID der Mitarbeiter, die nicht an den afugelisteten Fluegen beteiligt sind.\n\n\n\ncid\n\n\n\n\nc090\n\n\n\nGebe die Flugnummer der Fluege, die in Deutschland starten.\n\n\n\nFlugnr\n\n\n\n\nDB2013\n\n\nDB2341\n\n\n\nGebe alle Modelle aus, fuer die eine Crew-Mitglied zugelassen ist.\n\n\n\nZulassung\n\n\n\n\nA320\n\n\nB787\n\n\nA380\n\n\nA340\n\n\nB747\n\n\n\nGebe alle Namen von Piloten aus, die fuer eine Maschine zugelassen sind mit Reichweite \\(\\leq 10000\\).\n\n\n\nName\n\n\n\n\nPan\n\n\nSchmitt\n\n\n\nGebe Start, Ziel und Modell fuer alle Modelle aus, die ungeiegnet fuer einen Flug sind, weil sie die Strecke nicht fliegen koennen.\n\n\n\nStart\nZiel\nModell\n\n\n\n\nFRA\nJFK\nA320\n\n\nJFK\nFRA\nA320\n\n\nCDG\nLAX\nA320\n\n\n\nWaehle aus Fluegen die gleichen Flugnummern, die an unterschiedlichen Tagen fliegen, d.h gebe Flugnummern der Fluegen, die Rundfahrten sind.\n\n\n\nFlugnr\n\n\n\n\nDB2013\n\n\n\nGebe die Laender aus, aus denen keine Flugzeuge starten.\n\n\n\nLand\n\n\n\n\nDeutschland"
  },
  {
    "objectID": "01/blatt01.html#datenmanagementsysteme",
    "href": "01/blatt01.html#datenmanagementsysteme",
    "title": "1  Grundlagen der Relationalen Algebra",
    "section": "1.3 Datenmanagementsysteme",
    "text": "1.3 Datenmanagementsysteme\n\nXML und HTML basieren sich beide auf SGML - eine Metasprache, mit deren Hilfe man verschiedene Markup-sprachen fuer Dokumente definieren kann.\nXML ist eine erweiterbare Markup-sprache, die zur Darstellung & Speicherung hierarchisch strukturierter Daten und zur Definition & Entwicklung neuer Markup-sprachen verwendet wird. XML Dokumente haben eine Baumstruktur und bestehen aus Elemente, die durch Tags Ausgezeichnet werden. XML hat keinen vordifienerten Satz von Tags, wobei die genaue Struktur eines XML-Dokuments durch den Dokumenttypdefinition festgelegt werden kann.\nHTML beschreibt die semantische Struktur und Formattierung der Inhalte von Webseiten und war urspruenglich eine Anwendung von SGML. Im Gegensatz zu XML hat HTML einen festen Satz von Tags, die fuer die Auszeichnung der Elementen verwendet werden koennen. Streng genommen ist HTML kein XML hat aber im wesentlichen die gleiche Struktur wie ein XML-Dokument. (Hierarchische Baumstruktur, Elemente, Tags, DOM).\nFuer XML gibt es viele standarte Werkzeuge, die XML Dokumente auf Wohlgeformtheit pruefen und porgrammatsich verarbeiten koennen, z.B. wie\n\nXML-Prozessor/Parser,\nXQuery: die standarde XML Abfrage- und Transformationssprache,\nXPath: Untersprache von XQuery, die XQuery unterstuetzt,\nXSLT: Sprache die speziell dazu geiegnet ist, XML Dokumente in andere Formate umzuwandeln.\n\nDiese Tools stehen in XML Datenbanken zur verfuegung und XML Datenbanken sind fuer die Arbeit mit XML-Dokumenten optimiert. Somit koennen HTML-Dokumente mit den etablierten zahlreichen XML Tools optimal verarbeitet werden, wenn sie in einer XML Datenbank gespeichert werden.\n\nEin weiterer Vorteil ist, dass eine XML-Datenbank kein oder nur ein vereinfachtes Datenschema (Beziehungsschema/Tabellen) braucht, da die Daten schon durch das Dateiformat strukturiert werden. Bei einer relationael Datenbank muss das Schema explizit definiert werden. D.h. um ein HTML-Dokument in einer RDB zu speichern, oder um ein Dokument aus einer RDB zu exportieren muss jedes mal eine Transformation zwischen der HTML-Darstellung und relationalen Darstellung des Dokuments durchgefuehrt werden. Weiterhin funktioniert die Abbildung zwischen den Dokument-orientierten und relationalen Modellen nicht immer gut und wird als object-relational impedence mismatch bezeichnet.\nVorteile:\n\nMan benoetigt kein vordefiniertes Schema\nKommt gut mit vielen Lese- und Schreibzugriffen zurecht.\n\nNachteile:\n\nGeringe konsistenzt/Gueltigkeit der Daten.\n\nWeil es weniger Einschraenkungen gibt, koennen die Abfragen nicht so gut optimiert werden wie bei den relationalen DBen."
  },
  {
    "objectID": "01/blatt01.html#feedback",
    "href": "01/blatt01.html#feedback",
    "title": "1  Grundlagen der Relationalen Algebra",
    "section": "1.4 Feedback",
    "text": "1.4 Feedback\nRose, Dimitrov, Barthelmes\n\nAufgabe 1:\n    a) Ja, technisch gesehen erfüllen Datenbanken, die nur ein Tier enthalten, die 1 und 4, wäre halt nur besser gewesen, wenn ihr ein \"normales\" Beispiel mit mindestens 2 Tieren gewählt hättet :D\n\n9/9 Punkte\n\nAufgabe 2:\n    1. Es wird das MODELL gesucht, nicht der NAME :D Also A380\n    5. Nicht ganz, es sind eher alle Personen, die nicht für ein Flugzeug mit Reichweite &gt;10000 zugelassen sind.\n    6. \"Ungeeignet\"? Habt ihr nie von technischen Zwischenstopps gehört? :p\n    7. Nicht unbedingt Rundfahrten\n    8. \"... Länder aus, die einen Flughafen haben, aus dem...\"\n\n8/11 Punkte\n\nAufgabe 3:\n\nHabt ihr ChatGPT verwendet? Das sieht sehr nach ChatGPT aus...\n\n4/4 Punkte\n\nInsgesamt 21/24 Punkte"
  },
  {
    "objectID": "02/blatt02.html#relationale-algebra---fortsetzung",
    "href": "02/blatt02.html#relationale-algebra---fortsetzung",
    "title": "2  Relationale Algebra und SQL",
    "section": "2.1 Relationale Algebra - Fortsetzung",
    "text": "2.1 Relationale Algebra - Fortsetzung\n\n\\(\\pi_{\\substack{\\texttt{pid, Name}}}\\bigl(\\sigma_{\\substack{\\texttt{Rolle=\"Pilot\"},\\\\ \\texttt{Reichweite}\\geq 15000}}(\\texttt{Personal}  \\bowtie \\texttt{Zulassung}  \\bowtie \\texttt{Modell})\\bigr)\\)\n\\(\\pi_{\\texttt{Name}}\\bigl(  \\sigma_{\\texttt{Land='USA'}}(  \\beta_{\\texttt{Code} \\leftarrow \\texttt{Ziel}}(\\texttt{Flug}) \\bowtie \\texttt{Flughafen} \\bowtie \\texttt{Flugzeug}  ) \\bigr)\\)\n\\(\\pi_{\\texttt{Code, Land}} \\Biggl(  \\sigma_{\\texttt{Name='F. Kohl'}}\\biggl(\\texttt{Flugzeug}  \\bowtie \\\\  \\Bigl(\\beta_{\\texttt{Code} \\leftarrow \\texttt{Start}}(\\pi_{\\texttt{Start, fid}}(\\texttt{Flug}))  \\cup  \\beta_{\\texttt{Code} \\leftarrow \\texttt{Ziel}}(\\pi_{\\texttt{Ziel, fid}}(\\texttt{Flug}))\\Bigr)\\biggr) \\biggr)\\)\n\\(\\pi_{\\texttt{pid, Name}}(\\texttt{Personal}) - \\\\  \\pi_{\\texttt{pid, Name}}(\\texttt{Personal} \\bowtie \\texttt{Crew} \\bowtie \\sigma_{\\texttt{Datum} &lt; \\texttt{07.04.2013}}(\\texttt{Flug}))\\)"
  },
  {
    "objectID": "02/blatt02.html#sql-anfragen",
    "href": "02/blatt02.html#sql-anfragen",
    "title": "2  Relationale Algebra und SQL",
    "section": "2.2 SQL-Anfragen",
    "text": "2.2 SQL-Anfragen\n\nSQL:\nselect distinct C from R3\nErgebniss:\n       {{C: 7}, \n        {C: 8}}\nSQL:\nselect distinct * from R2\nwhere B = rot\nErgebniss::\n         {{B: rot, C: 9}}\n         {{B: blau, C: 8}}\nSQL:\nselect distinct * from R2\nintersect\nselect distinct * from R3;\nErgebniss:\n         {{B: blau}, {C: 7}}\nSQL:\nselect * from R2\nunion\nselect * from R3\nErgebniss:\n         {{B: blau,  C: 7}, \n         {B: rot,   C: 8}, \n         {B: rot,   C: 9}, \n         {B: gruen, C: 8}, \n         {B: gelb,  C: 7}}\nSQL:\nselect * from R3 except (\n    select * from R2\n);\nErgebniss:\n         {{B: gruen, C: 8}, \n         {B: gelb,  C: 7}}\nSQL:\nselect distinct * from\nR1 natural jo R2\nErgebniss:\n         {{A: q, B: rot, C: 8}, \n         {A: q, B: rot, C: 9}}\nSQL:\nselect distinct * from\nR1, R2\nErgebniss:\n        {{A: q, R1.B: rot,   R2.B: blau,  C: 7 },\n        {A: q, R1.B: rot,   R2.B: gruen, C: 8},\n        {A: q, R1.B: rot,   R2.B: gelb,  C: 7},\n        {A: r, R1.B: gruen, R2.B: gelb,  C: 7},\n        {A: r, R1.B: gruen, R2.B: gruen, C: 8},\n        {A: r, R1.B: gruen, R2.B: gelb,  C: 7}}"
  },
  {
    "objectID": "02/blatt02.html#entsprechungen-in-sql-und-der-relationalen-algebra",
    "href": "02/blatt02.html#entsprechungen-in-sql-und-der-relationalen-algebra",
    "title": "2  Relationale Algebra und SQL",
    "section": "2.3 Entsprechungen in SQL und der relationalen Algebra",
    "text": "2.3 Entsprechungen in SQL und der relationalen Algebra\n\nDie Anfragen entsprechen sich liefern jedoch nicht das gleiche Ergebniss, da der SQL-Ausdruck Duplikate zulaesst, waehrend bei der relationalen Abfrage die Duplikate entfernt werden.\n\nDie SQL-Anfrage liefert die Bezeichnung der Modelle, die nach Flughafen ‘CDG’ fliegen/geflogen haben.\nDer relationale Ausdruck liefert die Sitzplatzkapazitaeten der selben Modelle aus der SQL-Anfrage.\n\nSomit sind die Ausdrucke nicht Aequivalent und sie entpsrechen sich nicht.\n\nDie erste SQL-Anrage gibt die ID’s der Co-Pilote und die Bezeichnungen der Modelle aus, dafuer sie zugelassen sind.\nDie zweite SQL-Anfrage gibt genau das gleiche Ergebniss wie die erste Anfrage. Man beachte, dass natural join in SQL immer von einem Kreuzprodukt und Selektionsoperationen simuliert werden kann.\n\nSomit sind die beiden Anfragen Aequivalent"
  },
  {
    "objectID": "02/blatt02.html#er-modell",
    "href": "02/blatt02.html#er-modell",
    "title": "2  Relationale Algebra und SQL",
    "section": "2.4 ER-Modell",
    "text": "2.4 ER-Modell\nSee the diagrams\n\n\n\n\n\n\nZeile 1\n\n\n\n\n\n\n\nZeile 2\n\n\n\n\n\n\n\n\n\nZeile 3\n\n\n\n\n\n\n\nZeile 4\n\n\n\n\n\n\n\n\n\nZeile 5"
  },
  {
    "objectID": "02/blatt02.html#feedback",
    "href": "02/blatt02.html#feedback",
    "title": "2  Relationale Algebra und SQL",
    "section": "2.5 Feedback",
    "text": "2.5 Feedback\nZur Aufgabe 1.\n\n1. Richtig, wenn auch &gt; statt &gt;= gemeint \n\n2. Richtig 3. Sollte passen 4. Richtig\n\nZur Aufgabe 2:\n\n1. Richtig 2. Ergebnis: Wieso B: Blau wenn ihr nach rot selektiert =&gt; - 0.25 P.\n\n3.-7. Richtig\n\nZur Aufgabe 3:\n\n1. Richtig unter der Annahme, dass Tabelle mehr als die abgedruckten Beispieldaten enthält (Stichwort Distinct)\n\n2. Ebenfalls richtig\n\n3. Dito\n\nZur Aufgab 4:\n\n1. Richtig 2. Verlage sollen laut ML bitte mindestens ein Buch verlegen =&gt; - 0.25P. 3. Laut ML bitte [1,*] =&gt; - 0.25 P.\n\n4. Richtig 5. Ebenfalls"
  },
  {
    "objectID": "03/blatt03.html#er-modellierung-staedte",
    "href": "03/blatt03.html#er-modellierung-staedte",
    "title": "3  ER-Modellierung",
    "section": "3.1 ER-Modellierung: Staedte",
    "text": "3.1 ER-Modellierung: Staedte\nER-Schema: Stadt\n\n\n\nER-Schema: Stadt"
  },
  {
    "objectID": "03/blatt03.html#er-modellierung-filmstudio-datenbank",
    "href": "03/blatt03.html#er-modellierung-filmstudio-datenbank",
    "title": "3  ER-Modellierung",
    "section": "3.2 ER-Modellierung: Filmstudio-Datenbank",
    "text": "3.2 ER-Modellierung: Filmstudio-Datenbank\n\nER-Schema Figure 3.1\n\n\n\n\nFigure 3.1: ER-Schema: NetMovie DB\n\n\n\nIntegriteatsbedingungen\n\ni.A. koennen die Wertebereiche der Attribute im ER-Diagram nicht spezifiert werden, z.B. wie\n\nErscheinungsjahr eines Films darf nicht in der Zukunft liegen oder ein sehr altes Datum wie 1776 sein.\nGage eines Regissuers muss &gt; 30,000 € sein\nGlobale Bedingungen wie z.B. Gesamtgehalt aus mehreren Filmen darf nie ueber 1000000 € sein koennen auch nicht spezifiziert werden.\n\nIn der Spezifikation heisst es, dass in jedem Film genau zwei Hauptrollen gibt. In unserem ER-Schema haben wir Hauptrolle als eine optionale Attribute des Beziehungstyps “wirkt-mit” modelliert. Diese Kardinalitaet kann somit nicht in unsrem ER-Schema bestimmt werden.\n\nAlternative Modellierungen\n\nGage als Attribute der Entitaet Film modellieren.\nEine neue Entitaet “Genre” einfuehren, und “arbeitet-in” Beziehungen zwischen Regisseur-Genre, und zwischen Schauspieler-Genre modellieren:"
  },
  {
    "objectID": "03/blatt03.html#feedback",
    "href": "03/blatt03.html#feedback",
    "title": "3  ER-Modellierung",
    "section": "3.3 Feedback",
    "text": "3.3 Feedback\nPunkte: 29.0/30"
  },
  {
    "objectID": "04/blatt04.html#uebersetzung-eines-er-schemas",
    "href": "04/blatt04.html#uebersetzung-eines-er-schemas",
    "title": "4  Uebersetzung ER-Schema in Relationenschemata",
    "section": "4.1 Uebersetzung eines ER-Schemas",
    "text": "4.1 Uebersetzung eines ER-Schemas\n\n\\(\\texttt{Addresse}(\\underline{\\texttt{Ad\\_ID}}\\texttt{,}\\, \\texttt{PLZ, Stadt, Strasse, Hausnr})\\)\n\\(\\ttt{MusikerIn}(\\underline{\\texttt{M\\_ID}}, \\texttt{Name, Geb\\_Datum, Ad\\_ID \\(\\rightarrow\\) Addresse)}\\)\n\\(\\ttt{Instrument}(\\underline{\\texttt{Name, Stimmung}})\\)\n\\(\\ttt{spielt}(\\underline{\\texttt{M\\_ID\\(\\rightarrow\\)MusikerIn, (Name, Stimmung)\\(\\rightarrow\\)Instrument}}, \\texttt{bevorzugt})\\)\n\\(\\ttt{Musikstueck}(\\underline{\\texttt{MS\\_ID}}, \\texttt{Titel, Laenge, M\\_ID\\(\\rightarrow\\)MusikerIn)}\\)\n\\(\\ttt{Album}(\\underline{\\texttt{A\\_ID}}, \\texttt{Titel, Release\\_Datum, Preis, Tracks, M\\_ID\\(\\rightarrow\\)MusikerIn)}\\)\n\\(\\ttt{erscheint}(\\underline{\\texttt{M\\_ID\\(\\rightarrow\\)Musikstueck, A\\_ID\\(\\rightarrow\\)Album}}, \\texttt{TrackNr})\\)\n\\(\\ttt{spielt\\_mit}(\\underline{\\texttt{M\\_ID\\(\\rightarrow\\)MusikerIn, MS\\_ID\\(\\rightarrow\\)Musikstueck}})\\)"
  },
  {
    "objectID": "04/blatt04.html#uebersetzung-eines-er-schemas-mit-hierarchien",
    "href": "04/blatt04.html#uebersetzung-eines-er-schemas-mit-hierarchien",
    "title": "4  Uebersetzung ER-Schema in Relationenschemata",
    "section": "4.2 Uebersetzung eines ER-Schemas mit Hierarchien",
    "text": "4.2 Uebersetzung eines ER-Schemas mit Hierarchien\n\nRelationales Schema\n\n\n\\(\\ttt{Personal}(\\underline{\\texttt{Pers\\_ID}}, \\texttt{GebDat, Name, Vorname})\\)\n\\(\\ttt{MitarbeiterIn}(\\underline{\\texttt{Pers\\_ID\\(\\rightarrow\\)Personal}}, \\texttt{Bonus})\\)\n\\(\\ttt{KundIn}(\\underline{\\texttt{KundenID\\(\\rightarrow\\)Personal}}, \\texttt{Branche})\\)\n\\(\\ttt{ManagerIn}(\\underline{\\texttt{Pers\\_ID\\(\\rightarrow\\)MitarbeiterIn}}, \\texttt{Sektion})\\)\n\\(\\ttt{ProgrammiererIn}(\\underline{\\texttt{Pers\\_ID\\(\\rightarrow\\)MitarbeiterIn}}, \\texttt{Abschluss})\\)\n\\(\\ttt{Programmiersprache}(\\underline{\\texttt{ProgSP}})\\)\n\\(\\ttt{kann}(\\underline{\\texttt{ProgSP\\(\\rightarrow\\)Programmiersprache, Pers\\_ID\\(\\rightarrow\\)ProgrammiererIn}}, \\texttt{level})\\)\n\n\nWeitere Methoden fuer is-a:\n\n\n\nVorteil: Vermeidung der Redundanz und moeglichen Inkonsitenzenen, die dadurch enstehen koennen.\nNachteil: Erhoehter Rechenaufwand durch Zugriff auf Attribute der Oberentitaet nur mit Join.\n\n\nVorteil: Vermindertee Rechenaufwand durch direkten Zugriff auf Attribute ueber Tupel einziger Relation.\nNachteil: Redundante Speicherung der gleichen Informationen.\n\n\nVorteil: Vermindernde Komplexitaet des Datenbanks durch kleinere Anzahl von Relationen (eine Relation statt zwei oder drei)\nNachteil: Moegliche Inkonsitenzen durch den vielen Nullwerten, die von dem Nutzer bei Insertoperationen explizit als null gesetzt werden muessen."
  },
  {
    "objectID": "04/blatt04.html#feedback",
    "href": "04/blatt04.html#feedback",
    "title": "4  Uebersetzung ER-Schema in Relationenschemata",
    "section": "4.3 Feedback",
    "text": "4.3 Feedback\nPunkte: 26/28\n\nZur Aufgabe 1:\n\nBei Fremdschlüsselverweisen auf Relationen (z.B. in MusikerIn bitte sowas wie wohnt-&gt;Adresse) schreiben =&gt; -2P.\n\nRest der 1. passt.\n\nZur Aufgabe 2:\n\nZur 1:\n\nPasst alles.\n\nZur 2:\n\nEbenfalls."
  },
  {
    "objectID": "05/blatt05.html#grundlegende-anfragen",
    "href": "05/blatt05.html#grundlegende-anfragen",
    "title": "5  SQL-Anfragen",
    "section": "5.1 Grundlegende Anfragen",
    "text": "5.1 Grundlegende Anfragen\n\n\n\n\nselect real_name, created_at\nfrom twitter_user tu\nwhere typ = 'lobby' and \ndate(created_at) &lt;  timestamp '2009-06-30'\norder by created_at\n\n\nA 1.1\n\n\nreal_name\ncreated_at\n\n\n\n\nSascha Lobo\n2007-05-08 21:10:26\n\n\nnetzpolitik\n2007-10-24 14:34:50\n\n\nUlrich Müller\n2009-01-07 14:50:51\n\n\nMehr Demokratie e.V.\n2009-04-02 19:36:30\n\n\nCCC Updates\n2009-04-16 14:04:59\n\n\nabgeordnetenwatch.de\n2009-04-25 04:14:23\n\n\nLobbyControl\n2009-05-07 14:48:55\n\n\n\n\n\n\n\n\n\nselect twitter_name, like_count\nfrom twitter_user tu , tweet t \nwhere tu.id = t.author_id\nand t.like_count between 22000 and 25000;\n\n\nA 1.2\n\n\ntwitter_name\nlike_count\n\n\n\n\nSWagenknecht\n24656\n\n\nMAStrackZi\n22713\n\n\nn_roettgen\n22974\n\n\nn_roettgen\n24329\n\n\n\n\n\n\n\n\n\nselect distinct h.txt\nfrom \n    twitter_user tu , \n    tweet t , \n    hashtag_posting hp , \n    hashtag h \nwhere tu.id = t.author_id  and \n    t.id = hp.tweet_id and\n    hp.hashtag_id = h.id and \n    tu.real_name = 'LobbyControl' and \n    t.created_at between '2023-01-01' and '2023-01-15'\norder by h.txt \n\n\nA 1.3\n\n\ntxt\n\n\n\n\nampel\n\n\nautogipfel\n\n\nautolobby\n\n\nbundestag\n\n\neu\n\n\nexxon\n\n\nexxonknew\n\n\nkorruptionsskandal\n\n\nlindner\n\n\nlobbyregister\n\n\n\n\n\n\n\n\nselect *\nfrom hashtag h\nwhere h.id in (\n    select hp1.hashtag_id \n    from hashtag_posting hp1, hashtag_posting hp2\n    where hp1.tweet_id = hp2.tweet_id and\n    hp1.hashtag_id = hp2.hashtag_id and not\n    hp1.pos_start = hp2.pos_start\n)\nAnzahl der Ergebnisse:\n\n\n\nA 1.4 Anzahl der Ergebnisse\n\n\ncount\n\n\n\n\n437\n\n\n\n\n\n\n\n\n\nselect real_name, follower_count\nfrom twitter_user\nwhere created_at &lt;= '2010-01-01'\nand follower_count &gt;= all (\n    select follower_count\n    from twitter_user\n    where created_at &lt;= '2010-01-01'\n)\n\n\nA 1.5\n\n\nreal_name\nfollower_count\n\n\n\n\nSascha Lobo\n761419"
  },
  {
    "objectID": "05/blatt05.html#string-funktionen",
    "href": "05/blatt05.html#string-funktionen",
    "title": "5  SQL-Anfragen",
    "section": "5.2 String-Funktionen",
    "text": "5.2 String-Funktionen\n\n\n\n\nselect txt \nfrom tweet\nwhere txt ilike '%openai%'\nand retweet_count &gt;= 20\n\n\nA 2.1\n\n\n\n\n\ntxt\n\n\n\n\nRT @_SilkeHahn: Guten Morgen: #OpenAI ist doch schon lange #ClosedAI. Seit der ersten Milliarde durch Microsoft 2019 lassen sie sich nicht mehr in die Karten schauen. @netzpolitik_org legt gekonnt den Finger in offene Wunden. Der “Technical Report” schweigt sich auf 98 https://t.co/ix1EYCAOKG… https://t.co/hAW5rbRUtH\n\n\nRT @DrScheuch: Die meisten Aerosolforscher haben damals schon sehr starke Zweifel am Sinn von Ausgangssperren geäußert, (#openairstattausgangssperre) wurden aber nicht gehört. @Karl_Lauterbach, die NoCovid Modellierer und @janoschdahmen waren die lautesten Befürworter. https://t.co/bL7QMaoyKP\n\n\n\n\n\n\n\n\n\nselect txt, char_length(txt) as Laenge\nfrom named_entity\nwhere char_length(txt) &gt;= all (\n    select char_length(txt)\n    from named_entity\n)\n\n\nA 2.2\n\n\ntxt\nlaenge\n\n\n\n\nArbeitsgemeinschaft Sozialdemokratischer Frauen\n47\n\n\n\n\n\n\n\n\n\nselect txt\nfrom named_entity\nwhere char_length(txt) &gt;= 4\nand txt like reverse(txt) \n\n\nA 2.3\n\n\ntxt\n\n\n\n\nDAAD\n\n\nGASAG\n\n\nCIMIC\n\n\nABBA"
  },
  {
    "objectID": "05/blatt05.html#exists-operatoren",
    "href": "05/blatt05.html#exists-operatoren",
    "title": "5  SQL-Anfragen",
    "section": "5.3 Exists-Operatoren",
    "text": "5.3 Exists-Operatoren\n\n\n\nselect *\nfrom named_entity ne\nwhere not exists (\n    select *\n    from named_entity_posting nep \n    where nep.named_entity_id = ne.id \n)\nAnzahl der Ergebnisse:\n\n\n\nA 3.1 Anzahl der Ergebnisse\n\n\ncount\n\n\n\n\n621\n\n\n\n\n\n\n\n\n\nselect txt \nfrom tweet t\nwhere exists (\n    select *\n    from hashtag_posting hp, hashtag h \n    where hp.hashtag_id = h.id \n    and t.id = hp.tweet_id \n    and h.txt = 'klima'\n) and exists (\n    select *\n    from named_entity_posting nep, named_entity ne \n    where nep.named_entity_id = ne.id \n    and t.id = nep.tweet_id \n    and ne.txt = 'Berlin'\n)\n\n\nA 3.2\n\n\n\n\n\ntxt\n\n\n\n\n😸 Erinnerung: Bis 31.01.2023 um 23:59 (Europe/Berlin 🕛) könnt ihr noch Themenvorschläge zur #nr23 machen. Z.B. zu #Klima-,#Sozial-,#Sport-,#Medizin-, #Lokal-, #Nonprofit- #Datenjournalismus, #crossborder #Diversität #Pressefreiheit etc.\n\n\nCall for Papers: https://t.co/zyyNCsFC0y https://t.co/aDfQOzRG1W\n\n\nRT @DieLinke_HH: Das #Klima retten, nicht den #Kapitalismus! Heute haben wir mit 12.000 anderen in #Hamburg beim #Klimastreik protestiert. 👏\n\n\n\nKlare Ansage an Rot/Grün in Hamburg und die Ampel in Berlin: Der Stillstand bei der Klimapolitik muss aufhören! 🌿 https://t.co/jbfQrCcQuh | |So sieht die #Verkehrswende von @spdhh und @GRUENE_Hamburg aus🤦\nFrei nach Fairy Ultra: Während in Berlin schon das #9EuroTicket anläuft, werden in #Hamburg noch die Preise erhöht\nSoziale #Klimapolitik geht anders!\n@9euroforever #Klima @LinksfraktionHH https://t.co/Fi0eC8km1M |\n\n\n\n\n\n\nselect tu.twitter_name , tu.real_name\nfrom twitter_user tu \nwhere exists (\n    select *\n    from tweet t , conversation c \n    where t.author_id = tu.id and \n    t.id = c.id and \n    array_length(c.tweets, 1) &gt;= 70 and \n    t.created_at &gt;= '2023-02-15'\n)\n\n\nA 3.3\n\n\ntwitter_name\nreal_name\n\n\n\n\nsalomon_alex\nAlexander Salomon\n\n\nHendrikWuest\nHendrik Wüst"
  },
  {
    "objectID": "05/blatt05.html#aggregat-funktionen-und-gruppierung",
    "href": "05/blatt05.html#aggregat-funktionen-und-gruppierung",
    "title": "5  SQL-Anfragen",
    "section": "5.4 Aggregat-Funktionen und Gruppierung",
    "text": "5.4 Aggregat-Funktionen und Gruppierung\n\n\n\nselect ne.id, ne.txt, count(*) as Anzahl\nfrom named_entity ne , named_entity_posting nep \nwhere ne.id = nep.named_entity_id \ngroup by ne.id \norder by count(*) desc\nAnzahl der Ergebnisse:\n\n\n\nA 4.1 Anzahl der Ergebnisse\n\n\ncount\n\n\n\n\n15744\n\n\n\n\n\n\n\n\nselect tu.real_name, count(*) as anzahl\nfrom twitter_user tu , tweet t\nwhere tu.id = t.author_id and \ntu.typ = 'politician' and \nt.created_at &gt; '2022-01-01' and\ntu.tweet_count &gt; 2000 \ngroup by tu.id\norder by anzahl desc\nAnzahl der Ergebnisse:\n\n\n\nA 4.2 Anzahl der Ergebnisse\n\n\nanzahl_der_ergebnisse\n\n\n\n\n913\n\n\n\n\n\n\n\n\n\nwith erg(id, anzahl) as (\n    select nep.tweet_id, count(*) anzahl\n    from named_entity_posting nep, tweet t \n    where nep.tweet_id = t.id\n    group by tweet_id \n    having count(*) &gt;= all (\n        select count(*)\n        from named_entity_posting nep \n        group by tweet_id  \n    )\n)\nselect created_at, txt\nfrom tweet\nwhere id in (\n  select id\n  from erg\n)\n\n\nA 4.3\n\n\n\n\n\n\ncreated_at\ntxt\n\n\n\n\n2023-01-06 07:50:05\nAdrian, Alexander, Ariturel, Björn, Christian, Christian, Christian, Christopher, Cornelia, Danny, Dirk, Frank, Heiko, Johannes, Kai, Katharina, Kurt, Maik, Martin, Michael, Oliver, Robbin, Roman, Sandra, Scott, Stefanie, Stefan, Stephan, Stephan, Sven.\n\n\n\nVerdächtig? 🕵️‍♂️ @cduberlin |\n\n\n\n\n\n\nselect date(created_at), count(*)\nfrom tweet\ngroup by date(created_at)\nhaving date(created_at) &gt; '2022-12-31'\nand count(*) &gt;= all (\n    select count(*)\n    from tweet\n    group by date(created_at)\n    having date(created_at) &gt; '2022-12-31'\n)\n\n\nA 4.4\n\n\ndate\ncount\n\n\n\n\n2023-01-25\n3568"
  },
  {
    "objectID": "05/blatt05.html#feedback",
    "href": "05/blatt05.html#feedback",
    "title": "5  SQL-Anfragen",
    "section": "5.5 Feedback",
    "text": "5.5 Feedback\nPunkte: 42.5/43     \n\nZur Aufgabe 1:\n\n1.-5. Richtig\n\nZur Aufgabe 2:\n\n1.-3. Richtig\n\nZur Aufgabe 3:\n\n1.-3. Richtig\n\nZur Aufgabe 4:\n\n1. Richtig 2. Gemeint waren nur Tweets im Datensatz, sonst wäre das etwas einfach (mit HAVING anzahl &gt;2000) =- 0.5 P.\n\n3.-4. Richtig"
  },
  {
    "objectID": "06/blatt06.html#data-definition-language-ddl-und-rekursion-in-sql",
    "href": "06/blatt06.html#data-definition-language-ddl-und-rekursion-in-sql",
    "title": "6  Rekursion, Relationale Algebra und SQL",
    "section": "6.1 Data Definition Language (DDL) und Rekursion in SQL",
    "text": "6.1 Data Definition Language (DDL) und Rekursion in SQL\n\n\n\ncreate table taxonomy(\n    id int,\n    name varchar,\n    primary key(id),\n    parent int,\n    foreign key (parent) references taxonomy(id)\n);\n\ninsert into taxonomy\nvalues \n    (0, 'animals', null),\n    (2, 'chordate', 0),\n    (1, 'athropod', 0),\n    (6, 'mammals', 2),\n    (5, 'reptiles', 2),\n    (3, 'insects', 1),\n    (4, 'crustacean', 1),\n    (9, 'carnivora', 6),\n    (8, 'scaled reptiles', 5),\n    (7, 'crocodiles', 5),\n    (10, 'cats', 9),\n    (11, 'pan-serpentes', 8);\n\n\n\n\nselect name\nfrom taxonomy \nwhere parent = 2\n  union\nselect name \nfrom taxonomy t1\nwhere exists (\n    select name\n    from taxonomy t2\n    where t1.parent = t2.id\n    and t2.parent = 2\n)\n\n\nA 1.2\n\n\nname\n\n\n\n\ncarnivora\n\n\nreptiles\n\n\ncrocodiles\n\n\nscaled reptiles\n\n\nmammals\n\n\n\n\n\n\n\n\n\nwith recursive subCatOfChordate(id, name) as (\n    select id, name\n    from taxonomy t\n    where t.parent = 2\n        union\n    select t.id, t.name\n    from taxonomy t, subCatOfChordate s\n    where t.parent = s.id\n) \nselect id\nfrom subcatofchordate \n\n\nA 1.2\n\n\nid\n\n\n\n\n6\n\n\n5\n\n\n9\n\n\n8\n\n\n7\n\n\n10\n\n\n11"
  },
  {
    "objectID": "06/blatt06.html#relationale-algebra-und-sql",
    "href": "06/blatt06.html#relationale-algebra-und-sql",
    "title": "6  Rekursion, Relationale Algebra und SQL",
    "section": "6.2 Relationale Algebra und SQL",
    "text": "6.2 Relationale Algebra und SQL\n\n\n\n\nrel: \\(\\pi_{\\texttt{real\\_name, tweet\\_count, follower\\_count}}\\Bigl( \\\\ \\sigma_{\\texttt{created\\_at &gt; 01.01.2019, follower\\_count &gt; 8000, tweet\\_count &gt; 1000, like\\_count &gt; 1000}} \\\\(\\beta_{\\texttt{author\\_id} \\leftarrow \\texttt{id}}(\\texttt{twitter\\_user}) \\bowtie \\beta_{\\texttt{ca}\\leftarrow\\texttt{created\\_at}}(\\texttt{tweet})) \\Bigr)\\)\nsql:\n\n\nselect tu.real_name, tu.tweet_count, tu.follower_count\nfrom twitter_user tu \nwhere tu.created_at &gt; '2019-01-01'\nand tu.follower_count &gt; 8000\nand tu.tweet_count &gt; 1000\nand exists (\n    select *\n    from tweet t \n    where t.author_id = tu.id \n    and t.like_count &gt; 1000\n)\n\n\nA 2.1\n\n\nreal_name\ntweet_count\nfollower_count\n\n\n\n\nRote Socke Türk-Nachbaur\n16692\n21283\n\n\nUrsula von der Leyen\n3675\n1295550\n\n\nVerteidigungsministerium\n8923\n120387\n\n\nCarmen Wegge\n1029\n9355\n\n\n\n\n\n\n\n\n\nrel: \\(\\pi_{\\texttt{txt, author\\_id, created\\_at}}(\\sigma_{\\texttt{like\\_count &gt; 1000}}(\\texttt{tweet}) - \\\\ \\pi_{\\texttt{txt, author\\_id, created\\_at}}\\Bigl(\\\\ \\sigma_{\\texttt{created\\_at &gt; ca}}\\bigl(\\sigma_{\\texttt{like\\_count &gt; 1000}}(\\texttt{tweet}) \\times \\beta_{\\texttt{ca} \\leftarrow \\texttt{created\\_at}, \\texttt{ai}\\leftarrow \\texttt{author\\_id}, \\texttt{t} \\leftarrow \\texttt{txt}}(\\sigma_{\\texttt{like\\_count &gt; 1000}}(\\texttt{tweet}))\\bigr)\\Bigr)\\)\nsql:\n\n\nselect t.txt, t.author_id, t.created_at \nfrom tweet t\nwhere t.like_count &gt;= 1000\nand t.created_at &lt;= all (\n    select created_at \n    from tweet\n    where like_count &gt;= 1000\n)\n\n\nA 2.3\n\n\n\n\n\n\n\ntxt\nauthor_id\ncreated_at\n\n\n\n\nDie Leute haben heute aus Trotz geböllert, oder? Das nahm ja kein Ende. 😄😂 Genial! Danke. ⭐️🎆\n814970546366611457\n2023-01-01 00:17:32\n\n\n\n\n\n\n\n\n\nrel: \\(\\pi_{\\texttt{hi, hashtag\\_id}}\\Biggl(\\sigma_{\\texttt{ti &lt; tweet\\_id}}\\Bigl(\\\\ \\beta_{\\texttt{ti} \\leftarrow \\texttt{tweet\\_id}}\\bigl( \\sigma_{\\texttt{hi &lt; hashtag\\_posting}}(\\texttt{hashtag\\_posting} \\bowtie \\beta_{\\texttt{hi} \\leftarrow \\texttt{hashtag\\_id}}(\\texttt{hashtag\\_posting}))\\bigr) \\\\ \\bowtie \\\\ \\sigma_{\\texttt{hi &lt; hashtag\\_posting}}(\\texttt{hashtag\\_posting} \\bowtie \\beta_{\\texttt{hi} \\leftarrow \\texttt{hashtag\\_id}}(\\texttt{hashtag\\_posting}))\\Bigr)\\Biggr)\\)\nsql:\n\nwith hashtagpairs as (\n    select \n        hp1.hashtag_id h1_id, \n        h1.txt h1_txt, \n        hp2.hashtag_id  h2_id, \n        h2.txt h2_txt, \n        hp1.tweet_id tid\n    from hashtag_posting hp1, hashtag_posting hp2, hashtag h1, hashtag h2\n    where hp1.tweet_id  = hp2.tweet_id\n    and h1.id = hp1.hashtag_id \n    and h2.id = hp2.hashtag_id \n    and hp1.hashtag_id  &lt; hp2.hashtag_id \n)\nselect hpr1.h1_txt, hpr1.h2_txt\nfrom hashtagpairs hpr1\nwhere exists (\n    select *\n    from hashtagpairs hpr2\n    where hpr1.h1_id = hpr2.h1_id\n    and hpr1.h2_id = hpr2.h2_id\n    and hpr1.tid &lt; hpr2.tid\n) \n\n\n\nA 3.3 Anzahl der Ergebnisse\n\n\ncount\n\n\n\n\n178346"
  },
  {
    "objectID": "06/blatt06.html#regulaere-ausdruecke-in-sql",
    "href": "06/blatt06.html#regulaere-ausdruecke-in-sql",
    "title": "6  Rekursion, Relationale Algebra und SQL",
    "section": "6.3 Regulaere Ausdruecke in SQL",
    "text": "6.3 Regulaere Ausdruecke in SQL\n\nselect tu.real_name, regexp_count(t.txt, '\\m[[:upper:]]{2,}\\M') as cnt, t.txt\nfrom tweet t, twitter_user tu \nwhere tu.typ = 'politician'\nand t.author_id  = tu.id\nand regexp_count(t.txt, '\\m[[:upper:]]{2,}\\M') &gt;= all (\n    select regexp_count(txt, '\\m[[:upper:]]{2,}\\M')\n    from tweet\n)\n\n\nA 3\n\n\n\n\n\n\n\nreal_name\ncnt\ntxt\n\n\n\n\nUdo Hemmelgarn, MdB\n41\nRT @Georg_Pazderski: BITTE BITTE BITTE BITTE\n\n\n\nBITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE BITTE https://t.co/snBGvZGABI |"
  },
  {
    "objectID": "06/blatt06.html#feedback",
    "href": "06/blatt06.html#feedback",
    "title": "6  Rekursion, Relationale Algebra und SQL",
    "section": "6.4 Feedback",
    "text": "6.4 Feedback\nPunkte: 33/33\n\nZur Aufgabe 1:\n\n1.-3. Richtig\n\nZur Aufgabe 2:\n\n1.-3. Richtig\n\nZur Aufgabe 3:\n\nGeht einfacher, aber richtig."
  },
  {
    "objectID": "07/blatt07.html#fortgeschrittene-sql-anfragen",
    "href": "07/blatt07.html#fortgeschrittene-sql-anfragen",
    "title": "7  SQL und Anfragesprachen",
    "section": "7.1 Fortgeschrittene SQL-Anfragen",
    "text": "7.1 Fortgeschrittene SQL-Anfragen\n\n\n\n\nselect tu.real_name , tu.twitter_name \nfrom twitter_user tu \nwhere tu.typ = 'politician'\nand exists (\n    select *\n    from twitter_user tu2 \n    where tu2.twitter_name &lt;&gt; tu.twitter_name \n    and tu2.real_name = tu.real_name \n)\n\n\nA1.1\n\n\nreal_name\ntwitter_name\n\n\n\n\nMartin Hagen\n_MartinHagen\n\n\nMartin Hagen\nMartinHagenHB\n\n\n\n\n\n\n\n\n\nselect \n    tu.real_name real_name,\n    tu.twitter_name twitter_name,\n    tu.follower_count follower_count,\n    tu.tweet_count tweet_count,\n    array_length(c.tweets, 1) conversation_length\nfrom tweet t, conversation c, twitter_user tu \nwhere t.id = c.id\nand tu.id = t.author_id \nand array_length(c.tweets, 1) &gt;= all (\n    select array_length(c2.tweets, 1)\n    from conversation c2\n)\n\n\nA1.2\n\n\n\n\n\n\n\n\n\nreal_name\ntwitter_name\nfollower_count\ntweet_count\nconversation_length\n\n\n\n\nChristian Lindner\nc_lindner\n653690\n18882\n86\n\n\nTom Schreiber\nTomSchreiberMdA\n5328\n48186\n86\n\n\n\n\n\n\n\n\n\nselect ne.txt, ne.id, count(*)\nfrom \n    tweet t, \n    hashtag_posting hp, \n    hashtag h, \n    named_entity ne,\n    named_entity_posting nep \nwhere t.id = hp.tweet_id \nand hp.hashtag_id = h.id \nand h.txt ilike 'energie'\nand nep.tweet_id = t.id\nand nep.named_entity_id = ne.id\ngroup by ne.txt, ne.id\nhaving count(*) &gt;= 4\norder by count(*) desc\n\n\nA1.3\n\n\ntxt\nid\ncount\n\n\n\n\nDeutschland\n31\n18\n\n\nBayern\n240\n7\n\n\nThüringen\n526\n6\n\n\nAnschluss\n1741\n5\n\n\nBerlin\n2\n4\n\n\nBernhard Stengele\n11253\n4\n\n\nCDU\n65\n4\n\n\nEuropa\n217\n4\n\n\nBund\n655\n4\n\n\n\n\n\n\n\n\n\nselect\n    ne.id entity_id,\n    ne.txt entity_txt,\n    date(t.created_at) datum,\n    count(*) anzahl\nfrom \n    tweet t ,\n    named_entity_posting nep ,\n    named_entity ne \nwhere t.id = nep.tweet_id \nand ne.id =nep.named_entity_id \ngroup by ne.id, ne.txt, date(t.created_at)\norder by count(*) desc \nlimit 5\n\n\nA1.4\n\n\nentity_id\nentity_txt\ndatum\nanzahl\n\n\n\n\n6\nUkraine\n2023-02-24\n761\n\n\n2\nBerlin\n2023-02-12\n427\n\n\n28\nBundestag\n2023-03-17\n286\n\n\n2\nBerlin\n2023-02-10\n283\n\n\n1425\nCSU\n2023-03-17\n259"
  },
  {
    "objectID": "07/blatt07.html#relationale-algebra-und-tupelkalkuel",
    "href": "07/blatt07.html#relationale-algebra-und-tupelkalkuel",
    "title": "7  SQL und Anfragesprachen",
    "section": "7.2 Relationale Algebra und Tupelkalkuel",
    "text": "7.2 Relationale Algebra und Tupelkalkuel\n\n\n\n\numg: Was sind die echten Namen von allen Twitter Benutzern, die Lobbyisten sind, die einen Tweet mit ueber 2000 Likes veroeffentlicht haben, der die EU oder die USA erwaehnt?\ntup:\n\n\\[\\begin{align*}\n  \\{\\langle\\texttt{tu.real\\_name}\\rangle \\mid & \\texttt{tu} \\in \\texttt{twitter\\_user} \\wedge \\texttt{tu.typ='lobby'} \\wedge \\exists\\texttt{t}\\exists\\texttt{ne}\\exists\\texttt{nep} (\\\\\n  &\\quad\\quad \\texttt{t} \\in \\texttt{tweet}\\, \\wedge \\\\\n  &\\quad\\quad \\texttt{ne} \\in \\texttt{named\\_entity}\\, \\wedge \\\\\n  &\\quad\\quad \\texttt{nep}\\in\\texttt{named\\_entity\\_posting}\\, \\wedge \\\\\n  &\\quad\\quad \\texttt{t.id = nep.tweet\\_id}\\, \\wedge \\\\\n  &\\quad\\quad \\texttt{ne.id = nep.named\\_entity\\_id}\\, \\wedge \\\\\n  &\\quad\\quad \\texttt{t.like\\_count &gt; 2000}\\, \\wedge \\\\\n  &\\quad\\quad \\texttt{t.author\\_id = tu.id}\\, \\wedge \\\\\n  &\\quad\\quad (\\texttt{ne.txt = 'EU'} \\vee \\texttt{ne.txt = 'USA})) \\}\n\\end{align*}\\]\n\n\n\n\numg: Was sind die IDs aller Authoren, die zwar einen Tweet mit dem Hashtag “openai” verfasst haben aber keinen mit dem Hashtag “chatgpt”.\ntup:\n\n\\[\\begin{align*}\n  \\{\\langle\\texttt{t.author\\_id}\\rangle \\mid & \\texttt{t} \\in \\texttt{tweet} \\wedge\\exists\\texttt{h}\\exists\\texttt{hp} ( \\\\\n                     &\\quad\\quad \\texttt{h} \\in\\texttt{hashtag}\\, \\wedge \\\\\n                     &\\quad\\quad \\texttt{hp} \\in\\texttt{hashtag\\_posting}\\, \\wedge \\\\\n                     &\\quad\\quad \\texttt{h.id = hp.hashtag\\_id}\\, \\wedge \\\\\n                     &\\quad\\quad \\texttt{hp.tweet\\_id = t.id}\\, \\wedge \\\\\n                     &\\quad\\quad \\texttt{h.txt = 'openai'})\\, \\wedge \\\\\n                     &\\quad\\quad \\neg\\exists\\texttt{h}\\exists\\texttt{hp}( \\\\\n                     &\\quad\\quad \\texttt{h} \\in\\texttt{hashtag}\\, \\wedge \\\\\n                     &\\quad\\quad \\texttt{hp} \\in\\texttt{hashtag\\_posting}\\, \\wedge \\\\\n                     &\\quad\\quad \\texttt{h.id = hp.hashtag\\_id}\\, \\wedge \\\\\n                     &\\quad\\quad \\texttt{hp.tweet\\_id = t.id}\\, \\wedge \\\\\n                     &\\quad\\quad \\texttt{h.txt = 'chatgpt'} )\\}\n  \\end{align*}\\]"
  },
  {
    "objectID": "07/blatt07.html#feedback",
    "href": "07/blatt07.html#feedback",
    "title": "7  SQL und Anfragesprachen",
    "section": "7.3 Feedback",
    "text": "7.3 Feedback\nPunkte: 28/28"
  },
  {
    "objectID": "08/blatt08.html#seiten-und-saetze",
    "href": "08/blatt08.html#seiten-und-saetze",
    "title": "8  Physiche Datenorganisation und Baeume",
    "section": "8.1 Seiten und Saetze",
    "text": "8.1 Seiten und Saetze\n\nSatzlaenge twitter_user\n\n\n\n\n\n\n\n\nAttribute\nTyp\nSatzlaenge\n\n\n\n\nid\nbigint\n8 byte\n\n\nfollower_count\ninteger\n4 byte\n\n\ntweet_count\ninteger\n4 byte\n\n\ntyp\nchar(11)/char(5) “politician”/“lobby”\n12 byte (1 byte Overhead)\n\n\ncreated_at\ntimestamp\n8 byte\n\n\ntwitter_name\ntext\n12 byte\n\n\nreal_name\ntext\n18 byte\n\n\n—\n—\n—\n\n\n\\(\\sum\\)\n\n54 byte\n\n\n\nSpeicherplatz der Header\n\nJede Page hat 24 Byte Header\nJedes Tupel hat 23 Byte Header\n\nD.h. jedes Tupel hat 54 Byte Nutzdaten + 23 Byte Header = 77 Byte.\nGroesse der Bloecke im PostgreSQL:\n\n\nselect current_setting('block_size');\n\n\nblock size\n\n\ncurrent_setting\n\n\n\n\n8192\n\n\n\n\n\n\nselect count(*)\nfrom twitter_user\n\n\nAnzahl der Tupel in der Relation twitter user\n\n\ncount\n\n\n\n\n1825\n\n\n\n\n\nAnzahl der Tupel pro Seite ca.:\n\nround(8192 / 77)\n\n[1] 106\n\n\nSomit ist die Anzahl der Seiten ungefaehr:\n\nround(1825 / 106)\n\n[1] 17\n\n\n\nAnzahl der Seiten der Relation `twitter_user’:\n\n\nselect relname, relpages \nfrom pg_class\nwhere relname = 'twitter_user'\n\n\nAnzahl der Seiten fuer twitter user\n\n\nrelname\nrelpages\n\n\n\n\ntwitter_user\n22\n\n\n\n\n\nAlso in Wirklichkeit werden 22 Seiten gebraucht statt 17 Seiten. D.h. mehr Speicher. Die Gruende dieser Abweichung sind u.a. mehr Speicher fuer:\n\nPageheader\nZeiger auf die Tupel\nSpecial-/Free Space in Pages\nOptionalen Zusatzelementen wie Null Bitmap in den Tuples"
  },
  {
    "objectID": "08/blatt08.html#b-baeume",
    "href": "08/blatt08.html#b-baeume",
    "title": "8  Physiche Datenorganisation und Baeume",
    "section": "8.2 B-Baeume",
    "text": "8.2 B-Baeume\n\nB-Baum 1.1 Figure 8.1\n\n\n\n\nFigure 8.1: B-Baum: A2.1\n\n\n\nB-Baum 1.2 Figure 8.2\n\n\n\n\nFigure 8.2: B-Baum: A2.1"
  },
  {
    "objectID": "08/blatt08.html#textb-baeume",
    "href": "08/blatt08.html#textb-baeume",
    "title": "8  Physiche Datenorganisation und Baeume",
    "section": "8.3 \\(\\text{B}^{+}\\)-Baeume",
    "text": "8.3 \\(\\text{B}^{+}\\)-Baeume\n\nB+-Baum 3.1 Figure 8.3\n\n\n\n\nFigure 8.3: B-Baum: A2.1\n\n\n\nDie Elemente in der sortierten Reihenfolge in den B+ Baum einfuegen, aber nicht durch ein normales Insert, sondern direkt an das Blatt ganz rechts einfuegen. Dadurch spart man sich die look-up Operation \\(\\mathcal{O}(\\log_m(n))\\) des insert, die ein groeseres Element als die bisherigen sowieso ganz rechts in Baum ablegen wuerde."
  },
  {
    "objectID": "08/blatt08.html#feedback",
    "href": "08/blatt08.html#feedback",
    "title": "8  Physiche Datenorganisation und Baeume",
    "section": "8.4 Feedback",
    "text": "8.4 Feedback\nPunkte: 19.5/24.0\n- A1: 5.0/8.0\n- A2: 6.5/8.0\n- A3: 8.0/8.0          \n\nZur Aufgabe 1:\n\n1. typ hat Länge 4, da enum =&gt; -0.5 P.\n\n2. Tupel Header richtig, Attribut-Größe fehlt =&gt; -0.5 P.\n\n3. So war die Aufgabe nicht gemeint, man sollte aus den Werten der 1. und 2. das Ausrechnen =&gt; -2 P.\n\n4. Richtig\n\nZur Aufgabe 2:\n\n1. Richtig 2. Beide Varianten nicht ganz richtig:\n\nGrundstruktur teilweise richtig: Links sehr nah an ML man müsste nur 43 und 37 tauschen (der angesprochene Leichtsinnsfehler), rechts bei Löschen eines Nicht-Blattknotens wird Element durch (längen-)lexikographisch nächst kleineres Element ersetzt, in diesem Fall die 47. Ab dann ändert sich logischerweise auch euer Baum im Vergleich zur ML.\n\n =&gt; -1.5 P.\n\nZur Aufgabe 3:\n\n1. Diese Woche war die ML falsch, deswegen habe ich hier einen Fehler beim Korrigieren gemacht. Nur Ma zu M wäre schön.\n\n2. Habe ich übersehen, ist richtig."
  },
  {
    "objectID": "09/blatt09.html#erweitarbares-hashing",
    "href": "09/blatt09.html#erweitarbares-hashing",
    "title": "9  Hashing, Indexzugriffe und Sortierung",
    "section": "9.1 Erweitarbares Hashing",
    "text": "9.1 Erweitarbares Hashing\n\nEinfuegen der Woerter des Limerick\n\n\n\n\n\n\nh\nbucket\n\n\n\n\n00\nWho, feared\n\n\n10\nMan, said\n\n\n01\nbeard\n\n\n11\nOld\n\n\n\n\n\n\n\n\n\nh\nbucket\n\n\n\n\n000\nhen, four\n\n\n001\nwho, feared\n\n\n10*\nman, said\n\n\n010\nbeard, built\n\n\n011\nowls, wren\n\n\n110\nlarks, nests\n\n\n111\nold, two\n\n\n\nLoeschen der Woerter\n\n\n\n\nh\nbucket\n\n\n\n\n000\nhen, four\n\n\n001\nwho, feared\n\n\n10*\nman, said\n\n\n010\nbuilt\n\n\n011\nwren\n\n\n110\nlarks\n\n\n111\n—\n\n\n\nDer Bucket fuer 111 ist leer und 010 bis 110 sind nur halbvoll. Somit wird die Spercherzelle vom Bucket 111 unnoetig reserviert / blockiert, und die Tabelle ist unausgeglichen\nEine Loesung waere ``Buckets zu verkleinern” also zwei Buckets der lokalen tiefe \\(t\\) zu einem bucket der tiefe \\(t - 1\\) zusammenzufassen, wenn ``zu wenig” Elemente dort enthalten sind bzw. die Buckets leer sind.\nEin Vorteil hiervon waere eine hoehere Speichereffizienz. Ein Nachteil der erhoehte Aufwand durch pruefen der Fuellmenge, mehr Kopieren, etc. Ausserdem koennte es zu vielen Kopier-operationen kommen, bei unguenstigen Einfuege-/Loeschoperationen. (Wiederholtes loeschen & einfuegen auf einen Bucket)."
  },
  {
    "objectID": "09/blatt09.html#sortierung",
    "href": "09/blatt09.html#sortierung",
    "title": "9  Hashing, Indexzugriffe und Sortierung",
    "section": "9.2 Sortierung",
    "text": "9.2 Sortierung\n\n25.000 Bloecke, 48 Bloecke im HS\n\n\\(\\frac{25000}{48} \\approx 521\\)\n\\(\\lceil\\log_{47}(521)\\rceil \\approx 1,625 \\approx 2\\)\n\\(2 \\cdot 25000 \\cdot (1 + 2) = 150000\\)\npasst bereits.\n\n24,000,000 Bloecke Relation, 64 Bloecke im HS\n\nAnzahl der Partitionen: \\(\\frac{24 000 000}{64} = 375 000\\)\n\\(\\lceil\\log_{63}{375 000}\\rceil = 4\\)\n\\[\\begin{align*}\n2 \\cdot 24.000.000 \\cdot (1 + \\lceil\\log_{63}{375 000}) &= 2 \\cdot 24.000.000\\cdot (1 + 4) \\\\\n                                                         &= 5 \\cdot 2 \\cdot 24.000.000 \\\\\n                                                         &= 240.000.000\n\\end{align*}\\]\n\\[\\begin{align*}\n\\log_{x}{\\frac{24 \\cdot 10^6}{x}} = 2 \\iff & x^2 = \\frac{24 \\cdot 10^6}{x} \\\\\n                                            & x^3 = 24 \\cdot 10^6 \\tag{Mult $x$} \\\\\n                                            & x = \\sqrt[3]{24\\cdot 10^6} \\tag{$\\sqrt[3]{\\bullet}$} \\\\\n                                            & x \\approx 289\n\\end{align*}\\]"
  },
  {
    "objectID": "09/blatt09.html#zugriffmethoden",
    "href": "09/blatt09.html#zugriffmethoden",
    "title": "9  Hashing, Indexzugriffe und Sortierung",
    "section": "9.3 Zugriffmethoden",
    "text": "9.3 Zugriffmethoden\n\nb) ist effizienter. Nur Tupel mit \\(d \\in [0, 500)\\) Kommen fuer die Ergebnisrelation in Frage. Dies laesst sich schnell mit \\(\\text{B}^{+}\\text{-Baum}\\) ausgeben, schneller als 7,8 mill Tupel zu scannen.\na) ist effektiver, denn es werden auf jeden Fall alle Elemente ausgegeben ausser \\(d = 1000000\\). Fuer dieses muss gepreuft werden ob \\(y &gt; 42 \\wedge y &lt; 50\\). Aber weil eh so gut wie alle Elemente ausgegeben werden macht Index-zugriff keinen Sinn.\nGesuch sind mindestens alle Tupel \\(t\\) mit \\(d \\in [7100000, 7150000)\\). Dies laesst sich gut mit \\(\\text{B}^{+}\\text{-Baum}\\) abfragen. Deshalb b).\nHier lohng es sich weider mit dem \\(\\text{B}^{+}\\text{-Baum}\\) eine Vorauswahl an Elementen zu machen, da \\(d \\in I_{1}[0, 100] \\vee d \\in I_{2}[8800, 9000) \\vee d\\in I_{3}[7000000, 7001000)\\) ein wesentlich kleinerer Wertebereich ist als die komplette Relation."
  },
  {
    "objectID": "09/blatt09.html#feedback",
    "href": "09/blatt09.html#feedback",
    "title": "9  Hashing, Indexzugriffe und Sortierung",
    "section": "9.4 Feedback",
    "text": "9.4 Feedback\nPunkte 24.0/28.0\n- A1: 10.0/10.0\n- A2: 8.0/10.0\n- A3: 6.0/10.0\n\nZur Aufgabe 1:\n\n1.-2. Richtig\n\nZur Aufgabe 2:\n\n1. Richtig 2. Richtig 3. Richtig 4. a) Trotzdem solltet ihr ausrechnen, wie viele Blöcke benötigt werden b) Es wird noch ein weiterer Block zum Sortieren benötigt =&gt; -2 P.\n\nZur Aufgabe 3:\n\n1. Falsch, da Tupel bereits sortiert sind =&gt; -2 P. 2. Richtig 3. Richtig 4. Richtig"
  },
  {
    "objectID": "10/blatt10.html#join-strategien",
    "href": "10/blatt10.html#join-strategien",
    "title": "10  Anfragebearbeitung",
    "section": "10.1 Join-Strategien",
    "text": "10.1 Join-Strategien\n\ncost: \\(b_r + \\lceil\\frac{b_{r}}{\\text{mem} - 1}\\rceil\\times b_{s}\\)\nR: 115000 Tupel, 30 pro Seite \\(\\Rightarrow\\) 3834 Seiten\nS: 22500 Tupel, 100 pro Seite \\(\\Rightarrow\\) 225 Seiten\nmem = 70\nSomit: \\(\\text{cost} = 225 + \\lceil\\frac{225}{69}\\rceil\\times 3834 = 15561\\)\nKosten sind minimal g.d.w. \\(b_r\\) Komplett in dem Speicher passt und noch eine Seite frei ist fuer \\(b_s \\Rightarrow 226\\):\n\\[\n\\text{cost} = 225 + \\lceil\\frac{225}{226 - 1}\\rceil\\cdot 3834 = 4059\n\\]\ncost: \\(b_r + p \\cdot b_s\\) mit \\(p = \\lceil\\frac{b_r}{\\text{mem} - 1}\\rceil\\)\n\\(\\Rightarrow\\) Kosten gleich wie Block-Nested-Loop.\nDa die Formeln zu Berechnung gleich sind, sind beide Algorithmen gleich optimal bei einer RAM-Groesse von 226 Sieten. (Kosten wie in 1.)\nY ist primary-key von S \\(\\Rightarrow\\) alle Werte sind Unique. D.h. ein tupel in R kann mit max einem Tupel aus S matchen aber ein Tupel aus S kann maximal mit allen Tupel aus R matchen.\nD.h. maximal: 115000 Tupel wenn alle aus R matchen.\nR: 30 Tupel Pro Seite,\nS: 100 Tupel pro Seite,\nS + R = ?\n\\[\\begin{align*}\n&r \\in R, s \\in S, p := \\text{Seite}\\\\\n&30r = p \\iff r = \\frac{1}{30}p \\\\\n&100s = p \\iff s = \\frac{1}{100} \\\\\n&x(s + r) = p \\\\\n\\Rightarrow  &x(\\frac{1}{30}p + \\frac{1}{100}p)  = p \\\\\n\\iff &x\\frac{13p}{300} = p \\\\\n\\iff  &x \\approx 23,07 \\approx 23 \\text{Tupel} \\tag{Annahme: nicht-Spannsaetze}\n\\end{align*}\\]\nSomit: \\(\\frac{115000\\text{ Tupel}}{23\\frac{\\text{Tupel}}{\\text{Seite}}} = 5000 \\text{ Seiten}\\)"
  },
  {
    "objectID": "10/blatt10.html#algebraische-optimierung",
    "href": "10/blatt10.html#algebraische-optimierung",
    "title": "10  Anfragebearbeitung",
    "section": "10.2 Algebraische Optimierung",
    "text": "10.2 Algebraische Optimierung\n\n\nselect tu.real_name, tw.txt\nfrom \n   tweet tw, \n   named_entity ne, \n   named_entity_posting nep,\n   twitter_user tu\nwhere tw.author_id = tu.id\n   and nep.tweet_id = tw.id\n   and nep.named_entity_id = ne.id\n   and tw.created_at &gt; '2022-04-15'\n   and tw.like_count &gt; 6000\n   and ne.txt like 'Berlin'\n   and tu.created_at &lt; '2015-01-01'\n\n\nA2.1\n\n\n\n\n\n\nreal_name\ntxt\n\n\n\n\nSahra Wagenknecht\nDas Manifest für Frieden hat jetzt schon eine Viertelmillion Unterstützer: https://t.co/uC3H0FBZix Druck von unten kann etwas bewirken! Lasst uns den Protest gegen #Waffenlieferungen und für #Frieden und #Diplomatie nun auch die Straße tragen: Am 25. Februar um 14 Uhr in Berlin\n\n\nHermann Gröhe\nGemeinsam haben wir heute fraktionsübergreifend als politische Patinnen und Paten von Opfern und Verfolgten des iranischen Regimes vor der iranischen Botschaft in Berlin protestiert. Wir sehen die Verbrechen des iranischen Regime! #IranRevoIution #JinJiyanAzadi #Iran https://t.co/rDZC6KpBA2\n\n\nSahra Wagenknecht\nGroßartig: Eine halbe Million Unterschriften für das #ManifestfuerFrieden nach einer Woche! Herzlichen Dank & gerne weiter verbreiten: https://t.co/uC3H0FBZix Und kommt zur #Friedenskundgebung am 25.02. um 14 Uhr vor dem Brandenburger Tor in Berlin! https://t.co/2jxKTNGNpH https://t.co/WWXWoV9NlD\n\n\nSahra Wagenknecht\nEin Jahr #Krieg ist mehr als genug! Es braucht Druck von unten für #Verhandlungen. Jeder verlorene Tag kostet weitere Menschenleben und bringt uns einem 3. Weltkrieg näher. Deshalb: Kommt am 25. Februar um 14 Uhr zur großen #Friedenskundgebung nach Berlin: https://t.co/2jxKTNGNpH https://t.co/yu5vc30uv1\n\n\nSahra Wagenknecht\nNicht alle Ukrainer ziehen mit Begeisterung an die Front, und wer zu #Verhandlungen aufruft, fordert keine Kapitulation. In der Berliner Zeitung begründe ich, warum wir morgen um 14 Uhr in Berlin ein Stoppzeichen gegen weitere Kriegs-#Eskalation\n\n\nsetzen. https://t.co/OblSye7pJ6\n\n\n\nSahra Wagenknecht\nAuf geht’s zur großen Kundgebung “Aufstand für den Frieden” am BRB Tor in Berlin - mit Reden von Alice Schwarzer, Brigade-General a.D. Erich Vad, Jeffrey Sachs, mir und Weiteren. Für jene, die nicht vor Ort sein können startet (hier) 14:00 ein Livestream: https://t.co/lNpFdi6sv7\n\n\nSevim Dağdelen, MdB\n50.000 Menschen auf der #Friedenskundgebung #AufstandFuerFrieden in Berlin am Brandenburger Tor!\n\n\n#b2502 https://t.co/lB5NZYruWX\n\n\n\nSahra Wagenknecht\nHeute kamen mehr als 50000 Menschen zu unserer Friedensdemo nach Berlin. Wir sind viele, das hat die Veranstaltung gezeigt. Ein herzliches Dankeschön an alle, die dabei waren!\n\n\nSahra Wagenknecht\nSchätzungsweise 50.000 Menschen nahmen gestern an unserer Friedenskundgebung am Brandenburger Tor in Berlin teil. Dazu haben Alice Schwarzer & ich eine Erklärung veröffentlicht: https://t.co/gBbEHxgS8Q\n\n\n\n\n\n\\[\\begin{align*}\n& \\pi_{\\texttt{tu.real\\_name, tw.txt}} \\Biggl( \\\\\n& \\quad\\quad\\sigma_{\\substack{\\texttt{nep.tweet\\_id = tw.id } \\wedge \\texttt{ tw.author\\_id = tu.id} \\wedge \\\\\n   \\texttt{nep.named\\_entity\\_id = ne.id } \\wedge \\texttt{ tw.created\\_at &gt; '15.04.2022'} \\wedge \\\\\n   \\texttt{tw.like\\_count } &gt; 6000 \\wedge \\texttt{ ne.txt like 'Berlin'} \\\\\n   \\texttt{tu.created\\_at &lt; '01.01.2015'}}} \\\\\n& \\quad\\quad\\quad \\Bigl(\\beta_\\texttt{tw}(\\texttt{tweet}) \\times \\beta_{\\texttt{ne}}(\\texttt{named\\_entity}) \\\\\n& \\quad\\quad\\quad\\quad\\quad \\times \\beta_{\\texttt{nep}}(\\texttt{named\\_entity\\_posting}\\times\\beta_{\\texttt{tu}}(\\texttt{twitter\\_user})\n   \\Bigr) \\\\\n&\\Biggr)\n\\end{align*}\\]\nSiehe Figure 10.1\nSiehe Figure 10.2\n\n\n\n\n\n\n\nFigure 10.1: A2.3: nicht optimiert\n\n\n\n\n\n\n\nFigure 10.2: A2.4: optimiert\n\n\n\n\n\n\n\nOperatorbaum mit pgadmin explain ?fig-a2-5\n\nDer Operatorbaum i.A. aehnlich zu dem Operatorbaum aus 4), in dem Sinne das 1. Die Selektionen ebenfalls nach unten geschoben wurden und immer vor den join-Operationen stehen. Denn wir haben hier ausserdem keine Krezuprodukte, sondern 2. alle Kreuzprodukte wurden durch joins ersetzt.\nSpannend it ausserdem, dass hier ein richtiger Anfrageplan vorliegt, da joins/scans genau definiert wurden (index-scan, hash inner join, …).\nDarueber hinaus ist die join Reihenfolge anders: Da die Seletion ueber der Relation named_entity nur ein Ergebnis liefert, steht diese ganz unten und haelt alle Folgeergebnisse schlank. (Alle joins machen nur einen loop. Steht wenn man auf die joins klickt)"
  },
  {
    "objectID": "10/blatt10.html#feedback",
    "href": "10/blatt10.html#feedback",
    "title": "10  Anfragebearbeitung",
    "section": "10.3 Feedback",
    "text": "10.3 Feedback\nPunkte: 18.0/23.0\n- A1: 7.0/11.0\n- A2: 11.0/12.0\n\nRose, Dimitrov, Barthelmes\n\nAufgabe 1:\n\n3. Naja, es wird ja nicht nach dem optimalen Algorithmus *aus 1 oder 2* gefragt, sondern nach dem optimalen Algorithmus überhaupt\n4. Falsche Formeln, falsches Ergebnis\n\n7/11 Punkte\n\nAufgabe 2:\n\nwo textdatei\n3. Es fehlen die Projektionen nach den notwendigen Attributen\n\n10/12 Punkte\n\nInsgesamt 17/23 Punkte"
  },
  {
    "objectID": "notes/01intro/intro.html#purposes-of-db",
    "href": "notes/01intro/intro.html#purposes-of-db",
    "title": "11  Intro",
    "section": "11.1 Purposes of DB",
    "text": "11.1 Purposes of DB\nTwo main uses of databases:\n\nonline transaction processing: large numer of users use the database, each user retrieving small amounts of data and performing small updates.\ndata analytics: processing of data to draw conclusions, infer rules or decision procedures."
  },
  {
    "objectID": "notes/01intro/intro.html#sql-ddl",
    "href": "notes/01intro/intro.html#sql-ddl",
    "title": "11  Intro",
    "section": "11.2 SQL DDL",
    "text": "11.2 SQL DDL\ncreate table department \n  (dept_name  char(20),\n   building   char(15),\n   budget     numeric(12, 2));\nSQL DDL supports integrity constraints"
  },
  {
    "objectID": "notes/01intro/intro.html#sql-dml",
    "href": "notes/01intro/intro.html#sql-dml",
    "title": "11  Intro",
    "section": "11.3 SQL DML",
    "text": "11.3 SQL DML\nsql is declarative. Input several tables, output always a single table. Example:\nsingle table input:\nselect instructor.name\nfrom instructor\nwhere instroctur.dept_name = 'History'\ntwo tables as input:\nselect instructor.ID, department.dept_name\nfrom instructor, department\nwhere \n  instructor.dept_name = department.dept_name and \n  department.budget &gt; 95000;"
  },
  {
    "objectID": "notes/01intro/intro.html#steps-to-db-design",
    "href": "notes/01intro/intro.html#steps-to-db-design",
    "title": "11  Intro",
    "section": "11.4 Steps to DB Design",
    "text": "11.4 Steps to DB Design\nComputer representation of some real world or imaginary complex system involves mainly two tasks:\n\nmodelling the data aspect of the system (data requirements)\nmodelling the behavior aspect of the system (functional requirements)\n\nModelling the data aspect falls under the domain of DBs design. Primary objects and their interrelationships must be determined according to the needs of the users of the system. Modelling behavior is a software design task. These tasks are interrelated and can reinforce/influence each other.\nSteps of DB design:\n\nrequirements analysis: precise specification of client requirements (what data needs to be modelled) by consulting with domain experts and prospective clients.\nconceptual design: a data model is chosen and the requirements are translated to the concepts of the data model (usually ER).\nthe resulting schema is reviewed to confirm that all data requirements are satisfied and that there are no conflicts. Redundant features can be removed too.\nbasically all necessary attributes to be captured are determined in this step. alternative to ER an automatic generation of tables can be achieved via a method called normalization.\nspecification of functional requirements: A precise conceptual schema facilitates determining the behavioral requirements. These in turn can reinforce and alter the data schema.\nlogical-design phase. Higher-level conceptual schema is mapped to the implementation data model of the database system (usually relational).\nphysical-design phase. The logical schema is automatically compiled to a physical implementation by the DBMS but the designer can manually refine and fine-tune the physical design."
  },
  {
    "objectID": "notes/01intro/intro.html#dbms-architecture",
    "href": "notes/01intro/intro.html#dbms-architecture",
    "title": "11  Intro",
    "section": "11.5 DBMS architecture",
    "text": "11.5 DBMS architecture\nThe general architecture of a DBMS can be broadly regarded as consisting of three main components:\n\nquerry processor\nstorage manager\ndisk storage\n\n\n11.5.1 Querry processor\nThe querry processor realizes an easiy access to data via a querry language: users don’t have to specify how to access the data but only what data to access. The particular algorithm/plan needed to access the data specified by the querry is automatically compiled by the querry processor. Querry processors try to optimize these algorithms as much as possible.\n\nDDL interpreter\nDML compiler: (query optimization)\nquerry evaluation engine: executes low-level instrocution generated by the DML compiler.\n\n\n\n11.5.2 Storage Manager\nDB are very large and cannot be stored entirely in the main memory. Also since persistent storage of data is always wanted, DB are stored on secomdary memory, usually disks.\nMovement of data from secondary memory is much slower than movement from main memory to CPU registers. Therefore the DB tries to structure the data in a way that movement from secondary memory to main memory is minimized. This can be fine-tuned by the DB designer.\nStorage Manager is responsible with the interaction with the file manager of the underlying OS. The raw data is ultimately stored on the disk using the file system of the OS. The storage manager translates the DML statements into low-level file-system commands.\nComponents of the storage manager:\n\nauthorization and integrity manager\ntransaction manager: Realizes concurrent and parallel access to data as well as the grouping sequences of db access querries as single atomic units (transactions). Ensures that DB state is consistent after such operations but also in case of failures. The transaction manager thus realizes\n\natomicity:\nconsistency\ndurability\n\nfile manager: allocation of space on disk and data structures used to represent information stored on disk\nbuffer manager: critical part of the DBS, since it is responsible for fetching data from disk storage into main memory and what data to cache in main memory. Enables the db to handle data sized much larger than the size of main memory.\n\nStorage manager also implements several data structures as part of the physical system implementation:\n\ndata files: store the DB itself.\ndata dictionary: metadata about the structure of the db, i.e. the schema. Used by many other components like the querry processor\nindices: Just like an index of a book can provide fast access to data by storing actualy physical address of data items having some particular value on some attribute or multiple attributes."
  },
  {
    "objectID": "notes/02introrel/rel.html#relational-model-uni-db",
    "href": "notes/02introrel/rel.html#relational-model-uni-db",
    "title": "12  Introduction to Relational Model and Relational Algebra",
    "section": "12.1 Relational Model Uni DB",
    "text": "12.1 Relational Model Uni DB\n\n\\(\\texttt{intstructor}(\\underline{\\texttt{ID}}, \\texttt{name}, \\texttt{dept\\_name}\\rightarrow \\texttt{department}, \\texttt{salary})\\)\n\\(\\textbf{\\ttt{course}}(\\underline{\\ttt{id}}, \\ttt{ title}, \\ttt{ dept\\_name} \\rightarrow \\ttt{ department}, \\ttt{ credits})\\)\n\\(\\textbf{\\ttt{prereq}}(\\underline{\\ttt{course\\_id} \\rightarrow \\ttt{ course}, \\ttt{ prereq\\_id} \\rightarrow \\ttt{ course}})\\)\n\\(\\textbf{\\ttt{department}}(\\underline{\\ttt{name}} , \\ttt{ building, } \\ttt{ budget})\\)\n\\(\\textbf{\\ttt{section}}(\\udl{\\ttt{course\\_id}, \\ttt{id}, \\ttt{ semester}, \\ttt{ year, }}(\\ttt{building}, \\ttt{ room\\_number}) \\rightarrow \\ttt{classroom}, \\ttt{ time\\_slot\\_id})\\)\n\\(\\textbf{\\ttt{teaches}}(\\udl{\\ttt{instructor\\_ID}\\rightarrow \\ttt{ instructor}, (\\ttt{ course\\_id, sec\\_id, semester, year}) \\rightarrow \\ttt{ section}})\\)\n\\(\\textbf{\\ttt{student}}(\\udl{\\ttt{ID}}, \\ttt{ name}, \\ttt{ dept\\_name}\\rightarrow \\ttt{ department}, \\ttt{ total\\_credit})\\)\n\\(\\textbf{\\ttt{takes}}(\\udl{\\ttt{student\\_ID} \\rightarrow \\ttt{student}, (\\ttt{course\\_id, section\\_id, semester, year}) \\rightarrow \\ttt{section}}, \\ttt{grade})\\)\n\\(\\textbf{\\ttt{advisor}}(\\udl{\\ttt{student\\_id} \\rightarrow \\ttt{ student}, \\ttt{ instructor\\_id} \\rightarrow \\ttt{ instructor}})\\)\n\\(\\textbf{\\ttt{classroom}}(\\udl{\\ttt{building, room\\_number}}, \\ttt{ capacity})\\)\n\\(\\textbf{\\ttt{time\\_slot}}(\\udl{\\ttt{id}, \\ttt{ day}, \\ttt{ start\\_time}}, \\ttt{ end\\_time})\\)"
  },
  {
    "objectID": "notes/02introrel/rel.html#relational-algebra",
    "href": "notes/02introrel/rel.html#relational-algebra",
    "title": "12  Introduction to Relational Model and Relational Algebra",
    "section": "12.2 Relational Algebra",
    "text": "12.2 Relational Algebra\n\n12.2.1 Select Operation\n\nInformation of all instructors from the physics department: \\[\\sigma_\\texttt{dept\\_name=\"Physics\"}(\\texttt{instructor})\\]\n\n\nselect *\nfrom instructor\nwhere dept_name = 'Physics'\n\n\n2 records\n\n\nid\nname\ndept_name\nsalary\n\n\n\n\n22222\nEinstein\nPhysics\n95000\n\n\n33456\nGold\nPhysics\n87000\n\n\n\n\n\n\nInformation of all instructors with salaries greater than 90,000 $:\n\n\\[\\sigma_{\\texttt{salary &gt; 90000}}(\\texttt{instructor})\\]\n\nselect *\nfrom instructor\nwhere salary &gt; 90000\n\n\n2 records\n\n\nid\nname\ndept_name\nsalary\n\n\n\n\n22222\nEinstein\nPhysics\n95000\n\n\n83821\nBrandt\nComp. Sci.\n92000\n\n\n\n\n\n\nInformation about all instructors from the physics department with salaries greater than 90000:\n\n\\[\\sigma_{\\texttt{dept\\_name = 'Physics'} \\wedge \\texttt{salary &gt; 90000}}(\\texttt{instructor})\\]\n\nselect *\nfrom instructor\nwhere salary &gt; 90000 and dept_name = 'Physics'\n\n\n1 records\n\n\nid\nname\ndept_name\nsalary\n\n\n\n\n22222\nEinstein\nPhysics\n95000\n\n\n\n\n\n\ncomparison of two different attributes of the same relation is possible, e.g. all departments whose name is the same as their building name:\n\n\\[\\sigma_{\\texttt{dept\\_name = building}}(\\texttt{department})\\]\n\nselect *\nfrom department\nwhere name = building\n\n\n0 records\n\n\nname\nbuilding\nbudget\n\n\n\n\n\n\n\n\n\n12.2.2 Project Operation\n\nlist ID, name and salary information of all instructors:\n\n\\[\\Pi_{\\texttt{ID, name, salary}}(\\texttt{instructor})\\]\n\nselect i.id, i.name, i.salary\nfrom instructor i\n\n\nDisplaying records 1 - 10\n\n\nid\nname\nsalary\n\n\n\n\n10101\nSrinivasan\n65000\n\n\n12121\nWu\n90000\n\n\n15151\nMozart\n40000\n\n\n22222\nEinstein\n95000\n\n\n32343\nEl Said\n60000\n\n\n33456\nGold\n87000\n\n\n45565\nKatz\n75000\n\n\n58583\nCalifieri\n62000\n\n\n76543\nSingh\n80000\n\n\n76766\nCrick\n72000\n\n\n\n\n\n\nexpressions of attributes are allowed, e.g. montly salaries: \\[\\Pi_{\\texttt{ID, name, salary/12}}(\\texttt{instructor})\\]\n\n\nselect id, name, salary / 12 as month_salary\nfrom instructor\n\n\nDisplaying records 1 - 10\n\n\nid\nname\nmonth_salary\n\n\n\n\n10101\nSrinivasan\n5416.667\n\n\n12121\nWu\n7500.000\n\n\n15151\nMozart\n3333.333\n\n\n22222\nEinstein\n7916.667\n\n\n32343\nEl Said\n5000.000\n\n\n33456\nGold\n7250.000\n\n\n45565\nKatz\n6250.000\n\n\n58583\nCalifieri\n5166.667\n\n\n76543\nSingh\n6666.667\n\n\n76766\nCrick\n6000.000\n\n\n\n\n\n\n\n12.2.3 Composition of Relational Operations\n\nfind the names of all instructors in the Physics department\n\n\\[\\Pi_{\\texttt{name}}(\\sigma_{\\texttt{dept\\_name = 'Physics'}}(\\texttt{instructor}))\\]\n\nselect name\nfrom instructor\nwhere dept_name = 'Physics'\n\n\n2 records\n\n\nname\n\n\n\n\nEinstein\n\n\nGold\n\n\n\n\n\n\n\n12.2.4 Cartesian (Cross) Product\nlet \\(r[R]\\) and \\(s[S]\\). If \\(R \\cap S = \\emptyset\\), then \\(r \\times s\\) is simply:\n\\[(r\\times s)[R \\cup S] := \\{t[R \\cup S] \\mid t[R] \\in r \\wedge t[S] \\in s\\}\\]\nIf \\(R \\cap S \\neq \\emptyset\\), equally named attributes must be distinguished. Let\n\\[R \\tilde{+} S := R \\oplus S \\bigcup_{x \\in R \\cap S}\\{R.x, S.x\\} \\] Then,\n\\[(r \\times s)[R \\tilde{+} S] := \\{t[R \\tilde{+} S] \\mid t[(R\\setminus S) \\cup \\bigcup_{x\\in R \\cap S}\\{R.x\\}] \\in t[R] \\wedge t[(S\\setminus R) \\cup \\bigcup_{x\\in R \\cap S}\\{S.x\\}] \\in t[S] \\}\\]\nProblem when \\(r \\times r\\). We must use rename.\n\n\n12.2.5 Rename Operation\nA whole relation can be renamed:\n\\[\\beta_{s}(r)\\]\nAttributes of a relation can be renamed:\n\\[\\beta_{b_1 \\leftarrow a_1, b_2 \\leftarrow a_2}(r)\\]\nAbove the attributes \\(a_1\\) and \\(a_2\\) of \\(r\\) are renamed to \\(b_1\\) and \\(b_2\\).\nUsing rename we can perform cross product of a relation with itself:\n\\[\\beta_{s}(r) \\times r\\]\nsql version:\nselect *\nfrom r, r as s\nExample illustrating rename:\n\nFind the ID and name of all instructors who earn more than the instructor whose ID is 12121:\n\n\\[\\Pi_{\\texttt{i.ID, i.name}}\\Bigl( \\sigma_{\\texttt{i.salary &gt; wu.salary}} (\\\\\\beta_{\\texttt{i}}(\\texttt{instructor} \\times \\beta_{\\texttt{wu}}(\\sigma_{\\texttt{id = 12121}}(\\texttt{instructor})))) \\Bigr)\\]\n\n\n12.2.6 Join Operation\n\n12.2.6.1 Natural Join\nfor \\(r[R]\\) and \\(s[S]\\) natural join is defined as:\n\\[r \\bowtie s := \\{t[R \\cup S] \\mid t[R] \\in r \\wedge t[S] \\in s\\}\\]\ne.g. \\(\\texttt{instructor} \\bowtie \\texttt{teaches}\\) gives all information about instructors and courses they teach:\n\n\n12.2.6.2 \\(\\theta\\)-Join\nGeneral \\(\\theta\\)-join for a predicate \\(\\theta\\) is defined as:\n\\[r \\bowtie_{\\theta} s := \\sigma_{\\theta}(r \\times s)\\] join can be expressed in terms \\(\\theta\\)-join with appropriate rename and projection operations.\n\n\n\n12.2.7 Set Operations\nfor relations \\(r\\) and \\(s\\) with compatible schemes \\(R\\) and \\(S\\) (compatible means same arities and corresponding domains) simply\n\n\\(\\texttt{r} \\cup \\texttt{s}\\)\n\\(\\texttt{r} \\cap \\texttt{s}\\)\n\\(\\texttt{r} \\setminus \\texttt{s}\\)\n\nexamples:\n\ncourses offered in 2017 fall semester or in 2018 spring semester:\n\n\\[\\begin{align*}\n&\\Pi_{\\texttt{course\\_id}}(\\sigma_{\\texttt{semester = 'Fall'}\\wedge\\texttt{year = 2017}}(\\texttt{section})) \\cup\\\\\n&\\Pi_{\\texttt{course\\_id}}(\\sigma_{\\texttt{semester = 'Spring'}\\wedge\\texttt{year = 2018}}(\\texttt{section}))\n\\end{align*}\\]\n\ncourses offered in 2017 fall semester and in 2018 spring semester:\n\n\\[\\begin{align*}\n&\\Pi_{\\texttt{course\\_id}}(\\sigma_{\\texttt{semester = 'Fall'}\\wedge\\texttt{year = 2017}}(\\texttt{section})) \\cap\\\\\n&\\Pi_{\\texttt{course\\_id}}(\\sigma_{\\texttt{semester = 'Spring'}\\wedge\\texttt{year = 2018}}(\\texttt{section}))\n\\end{align*}\\]\n\ncourses offered in 2017 fall semester but not in 2018 spring semester:\n\n\\[\\begin{align*}\n&\\Pi_{\\texttt{course\\_id}}(\\sigma_{\\texttt{semester = 'Fall'}\\wedge\\texttt{year = 2017}}(\\texttt{section})) \\setminus\\\\\n&\\Pi_{\\texttt{course\\_id}}(\\sigma_{\\texttt{semester = 'Spring'}\\wedge\\texttt{year = 2018}}(\\texttt{section}))\n\\end{align*}\\]\n\n\n12.2.8 Asssignment\nFor convenience we can name intermediate results of relational algebraic operations, by assigning them variable names:\n\\[\\begin{align*}\n& \\texttt{r} := \\Pi_{\\texttt{course\\_id}}(\\sigma_{\\texttt{semester = 'Fall'}\\wedge\\texttt{year = 2017}}(\\texttt{section})) \\\\\n& \\texttt{s} := \\Pi_{\\texttt{course\\_id}}(\\sigma_{\\texttt{semester = 'Spring'}\\wedge\\texttt{year = 2018}}(\\texttt{section})) \\\\\n& \\texttt{r} \\cup \\texttt{s}\n\\end{align*}\\]"
  },
  {
    "objectID": "notes/03introSQL/introsql.html#overview",
    "href": "notes/03introSQL/introsql.html#overview",
    "title": "13  Introduction to SQL",
    "section": "13.1 Overview",
    "text": "13.1 Overview\n\nData-definition language (DDL):\n\ndefining and modifying relation schemas\nintegrity constrains\nview definition\nauthorization: access rights to relations and views.\n\nData-manipulation language (DML): querry information from and modify tuples in relations\nTransaction Control: Specifying beginning and end points of transactions.\nEmbedded/dynamic SQL: how SQL is embedded in general-purpose programmig languages."
  },
  {
    "objectID": "notes/03introSQL/introsql.html#sql-ddl",
    "href": "notes/03introSQL/introsql.html#sql-ddl",
    "title": "13  Introduction to SQL",
    "section": "13.2 SQL DDL",
    "text": "13.2 SQL DDL\nfollowing can be specified:\n\nschema for each relation\nset of indices to be maintained for each relation\nsecurity and authorization information for each relation\nphysical storage structure of each relation on disk\n\n\n13.2.1 Basic Types\n\nchar(n): fixed n-long string. (full form: character(n) )\nvarchar(n): variable-length character string with max length n. (full form character varying(n))\nint (full form: integer)\nsmallint\nnumeric(p, d): p digits in total, d of the digits after decimal point.\nreal, double precision: floating-point / double precision floating point.\nfloat(n): Floating-point with precision of at least n digits.\n\n\n\n13.2.2 Basic Schema Definition\ncreate table department (\n    dept_name   varchar(20),\n    building    varchar(15),\n    budget      numeric(12,2),\n    primary key (dept_name) --primary key integrity constraint\n);\ngeneral form:\ncreate table r(\n    a1 domain1,\n    a2 domain2,\n    ...\n    a_n domain_n\n    [integrity constraint 1],\n    ...\n    [integrity constraing 2] -- these are optional\n)\n\n\n13.2.3 Basic Constraints:\n\nprimary key: a1, …, a_n together form the primary key of the relation:\nprimary key(a1, a2, ..., a_n)\nforeign key: a1, …, a_n together form a foreign key over a relation s, i.e. a1, …, a_n must be a primary key of some tuple in s (existence: referential integrity)\nforeign key (a1, a2, ..., a_n) references s\nnot null:\nname varchar(20) not null, --name can not be null\n\nconcrete example:\ncreate table instructor(\n  ID          varchar(5),\n  name        varchar(20) not null, --name can not be null\n  dept_name   varchar(20),\n  salary      numeric(8,2),\n  primary key (ID),\n  foreign key (dept_name) references department\n)\nNote that explicitly specifying the primary key of the referenced relation\nforeign key (dept_name) references department(dept_name)\nis also possible but not required.\n\n\n13.2.4 Altering the Schema\n\nremove a relation completely from the database schema:\ndrop table r; --not to be confused with 'delete from'\nmodify a relation schema:\nalter table r add a1 a2; -- add the attributes a1, a2 to the relation r\nalter table r drop a; -- drop/remove attribute a from the relation r\nsome dbs’ don’t support dropping single attributes but only whole tables."
  },
  {
    "objectID": "notes/03introSQL/introsql.html#basic-sql-querries",
    "href": "notes/03introSQL/introsql.html#basic-sql-querries",
    "title": "13  Introduction to SQL",
    "section": "13.3 Basic SQL Querries",
    "text": "13.3 Basic SQL Querries\nA typical sql querry has the form\nselect a1, ..., a_n\nfrom r1, ..., r_m\nwhere P -- P is a predicate/condition\n\nselect name\nfrom instructor\n\n\nDisplaying records 1 - 10\n\n\nname\n\n\n\n\nSrinivasan\n\n\nWu\n\n\nMozart\n\n\nEinstein\n\n\nEl Said\n\n\nGold\n\n\nKatz\n\n\nCalifieri\n\n\nSingh\n\n\nCrick\n\n\n\n\n\n\nselect dept_name\nfrom instructor\n\n\nDisplaying records 1 - 10\n\n\ndept_name\n\n\n\n\nComp. Sci.\n\n\nFinance\n\n\nMusic\n\n\nPhysics\n\n\nHistory\n\n\nPhysics\n\n\nComp. Sci.\n\n\nHistory\n\n\nFinance\n\n\nBiology\n\n\n\n\n\n\nselect distinct dept_name --removes duplicates\nfrom instructor\n\n\n7 records\n\n\ndept_name\n\n\n\n\nPhysics\n\n\nBiology\n\n\nElec. Eng.\n\n\nFinance\n\n\nComp. Sci.\n\n\nHistory\n\n\nMusic\n\n\n\n\n\nSelect allows arbitrary expressions of attributes. we can output 10% salary raise for instructors\n\nselect id, name, dept_name, salary * 1.1\nfrom instructor\n\n\nDisplaying records 1 - 10\n\n\nid\nname\ndept_name\n?column?\n\n\n\n\n10101\nSrinivasan\nComp. Sci.\n71500\n\n\n12121\nWu\nFinance\n99000\n\n\n15151\nMozart\nMusic\n44000\n\n\n22222\nEinstein\nPhysics\n104500\n\n\n32343\nEl Said\nHistory\n66000\n\n\n33456\nGold\nPhysics\n95700\n\n\n45565\nKatz\nComp. Sci.\n82500\n\n\n58583\nCalifieri\nHistory\n68200\n\n\n76543\nSingh\nFinance\n88000\n\n\n76766\nCrick\nBiology\n79200\n\n\n\n\n\n\n13.3.1 Where clause.\n\nNames of all instructors in the CS department who have salary greater than $70,000:\n\n\nselect name\nfrom instructor\nwhere dept_name = 'Comp. Sci.'\nand salary &gt; 70000\n\n\n2 records\n\n\nname\n\n\n\n\nKatz\n\n\nBrandt\n\n\n\n\n\n\n\n13.3.2 Joining Tables\n\nnames of instructors, names of their departments and the names of the buildings where departments are located:\n\n\nselect i.name, d.name as dept_name, building\nfrom instructor i, department d\nwhere i.dept_name = d.name\n\n\nDisplaying records 1 - 10\n\n\nname\ndept_name\nbuilding\n\n\n\n\nNishimoto\nBiology\nWatson\n\n\nCrick\nBiology\nWatson\n\n\nBrandt\nComp. Sci.\nTaylor\n\n\nKatz\nComp. Sci.\nTaylor\n\n\nSrinivasan\nComp. Sci.\nTaylor\n\n\nKim\nElec. Eng.\nTaylor\n\n\nSingh\nFinance\nPainter\n\n\nWu\nFinance\nPainter\n\n\nRoznicki\nHistory\nPainter\n\n\nCalifieri\nHistory\nPainter\n\n\n\n\n\n\nnames of instructors and identifiers of courses they have tought:\n\n\nselect i.name, t.course_id\nfrom instructor i, teaches t\nwhere i.id = t.instructor_id\n\n\nDisplaying records 1 - 10\n\n\nname\ncourse_id\n\n\n\n\nSrinivasan\nCS-101\n\n\nSrinivasan\nCS-315\n\n\nSrinivasan\nCS-347\n\n\nWu\nFIN-201\n\n\nMozart\nMU-199\n\n\nEinstein\nPHY-101\n\n\nEl Said\nHIS-351\n\n\nKatz\nCS-101\n\n\nKatz\nCS-319\n\n\nCrick\nBIO-101\n\n\n\n\n\n\nnames of instructors from the CS department and identifiers of courses that they have tought:\n\n\nselect i.name, t.course_id\nfrom instructor i, teaches t\nwhere i.id = t.instructor_id and i.dept_name = 'Comp. Sci.'\n\n\n8 records\n\n\nname\ncourse_id\n\n\n\n\nSrinivasan\nCS-101\n\n\nSrinivasan\nCS-315\n\n\nSrinivasan\nCS-347\n\n\nKatz\nCS-101\n\n\nKatz\nCS-319\n\n\nBrandt\nCS-190\n\n\nBrandt\nCS-190\n\n\nBrandt\nCS-319\n\n\n\n\n\n\n\n13.3.3 Renaming\n\nselect i.name as instructor_name, t.course_id -- as can be omitted\nfrom instructor as i, teaches as t -- as can be ommited\nwhere i.id = t.instructor_id\n\n\nDisplaying records 1 - 10\n\n\ninstructor_name\ncourse_id\n\n\n\n\nSrinivasan\nCS-101\n\n\nSrinivasan\nCS-315\n\n\nSrinivasan\nCS-347\n\n\nWu\nFIN-201\n\n\nMozart\nMU-199\n\n\nEinstein\nPHY-101\n\n\nEl Said\nHIS-351\n\n\nKatz\nCS-101\n\n\nKatz\nCS-319\n\n\nCrick\nBIO-101\n\n\n\n\n\nRenaming useful when comparing tuples in the same relation:\n\nnames of instructors whose salary is greater than at least one instructor in the biology department \\(\\approx\\) names of all instructors who earn more than the lowest paid instructor in the Biology department:\n\n\nselect distinct i.name\nfrom instructor i , instructor i2 \nwhere i.salary &gt; i2.salary and i2.dept_name = 'Biology'\n\n\n8 records\n\n\nname\n\n\n\n\nBrandt\n\n\nGold\n\n\nWu\n\n\nKim\n\n\nNishimoto\n\n\nKatz\n\n\nEinstein\n\n\nSingh\n\n\n\n\n\n\ncorrelation name = table alias = tuple variable\n\n\n\n13.3.4 String Operations\n\nconcatenation with ||\n\n\nvalues \n('hey' || ' there!')\n\n\n1 records\n\n\ncolumn1\n\n\n\n\nhey there!\n\n\n\n\n\n\nupper() and lower()\n\n\nvalues \n(upper('hey there')),\n(lower('HEY THERE'))\n\n\n2 records\n\n\ncolumn1\n\n\n\n\nHEY THERE\n\n\nhey there\n\n\n\n\n\n\nremoving spaces with trim()\n\n\nvalues \n(trim('hey   ' ) || ' there!')\n\n\n1 records\n\n\ncolumn1\n\n\n\n\nhey there!\n\n\n\n\n\n\n\n13.3.5 Pattern Matching\n\n%: matches any string\n_: matches any character\nexamples:\n\nintro%: any string beginning with ‘Intro’\n%Comp%: any string containing ‘Comp’ as a substring\n___: any string of exactly three characters\n___%: any string of at least three characters\n\nconcrete example; information of courses that have ‘comp’ as a substring in their title:\n\n\nselect *\nfrom course c\nwhere c.title ilike '%comp%' --ilike is case insensitive like\n\n\n2 records\n\n\nid\ntitle\ndept_name\ncredits\n\n\n\n\nBIO-399\nComputational Biology\nBiology\n3\n\n\nCS-101\nIntro. to Computer Science\nComp. Sci.\n4\n\n\n\n\n\n*Escaping special characters like “%” with “\":\n\nselect *\nfrom (\n    values\n    ('%15')\n) r(a)\nwhere a like '\\%%'  \n\n\n1 records\n\n\na\n\n\n\n\n%15\n\n\n\n\n\n\nDefining custom escape characters other than “\":\n\n\nselect *\nfrom (\n    values\n    ('%15')\n) r(a)\nwhere a like '^%%' escape '^' -- '^' is defined as the escape character\n\n\n1 records\n\n\na\n\n\n\n\n%15\n\n\n\n\n\n\n\n13.3.6 Ordering Display of Tuples\n\nordering\n\n\nselect name\nfrom instructor\nwhere dept_name  = 'Physics'\norder by name;\n\n\n2 records\n\n\nname\n\n\n\n\nEinstein\n\n\nGold\n\n\n\n\n\n\nordering order, multiple attributes\n\n\nselect *\nfrom instructor\norder by salary desc, name asc\n\n\nDisplaying records 1 - 10\n\n\nid\nname\ndept_name\nsalary\n\n\n\n\n30765\nGreen\nMusic\nNA\n\n\n22222\nEinstein\nPhysics\n95000\n\n\n83821\nBrandt\nComp. Sci.\n92000\n\n\n12121\nWu\nFinance\n90000\n\n\n33456\nGold\nPhysics\n87000\n\n\n98345\nKim\nElec. Eng.\n80000\n\n\n76543\nSingh\nFinance\n80000\n\n\n45565\nKatz\nComp. Sci.\n75000\n\n\n10032\nNishimoto\nBiology\n73120\n\n\n76766\nCrick\nBiology\n72000\n\n\n\n\n\n\n\n13.3.7 Between\n\nSELECT name\nfrom instructor i\nwhere i.salary BETWEEN 90000 and 100000\n\n\n3 records\n\n\nname\n\n\n\n\nWu\n\n\nEinstein\n\n\nBrandt\n\n\n\n\n\n\n\n13.3.8 Tuples in Where Predicates\nSELECT i.name, t.course_id\nfrom instructor i, teaches t\nwhere i.id = t.instructor_id and i.dept_name = 'Biology' \nis equivalent to\n\nSELECT i.name, t.course_id\nfrom instructor i, teaches t\nwhere (i.id, i.dept_name) = (t.instructor_id, 'Biology')\n\n\n2 records\n\n\nname\ncourse_id\n\n\n\n\nCrick\nBIO-101\n\n\nCrick\nBIO-301"
  },
  {
    "objectID": "notes/03introSQL/introsql.html#set-operations",
    "href": "notes/03introSQL/introsql.html#set-operations",
    "title": "13  Introduction to SQL",
    "section": "13.4 Set Operations",
    "text": "13.4 Set Operations\nSet operations eliminate duplicates by default. Duplicates retained by all keyword.\n\n13.4.1 Union\ncorresponds to \\(\\cup\\).\n\ncourses offered in 2017 Fall or 2018 Spring:\n\n\n(\n    select  course_id\n    from section\n    where semester = 'Fall' and year = 2017\n)\nUNION\n(\n    select course_id\n    from section\n    where semester = 'Spring' and year = 2018\n)\n\n\n8 records\n\n\ncourse_id\n\n\n\n\nCS-101\n\n\nCS-315\n\n\nCS-319\n\n\nCS-347\n\n\nFIN-201\n\n\nHIS-351\n\n\nMU-199\n\n\nPHY-101\n\n\n\n\n\n\n\n13.4.2 Intersect\nCorresponds to \\(\\cap\\).\n\nCourses offered in both Fall 2017 and Spring 2018:\n\n\n(\n    select  course_id\n    from section\n    where semester = 'Fall' and year = 2017\n)\nintersect\n(\n    select course_id\n    from section\n    where semester = 'Spring' and year = 2018\n)\n\n\n1 records\n\n\ncourse_id\n\n\n\n\nCS-101\n\n\n\n\n\n\n\n13.4.3 Except\nCorresponds to \\(\\backslash\\).\n\ncourses offered in the Fall 2017 but not in Spring 2018:\n\n\n(\n    select  course_id\n    from section\n    where semester = 'Fall' and year = 2017\n)\nexcept\n(\n    select course_id\n    from section\n    where semester = 'Spring' and year = 2018\n)\n\n\n2 records\n\n\ncourse_id\n\n\n\n\nPHY-101\n\n\nCS-347\n\n\n\n\n\n\nIllustrating how all works:\n\nunion all:\n\nwith r(a) as (\n    values\n    (1),\n    (1)\n), s(a) as (\n    values\n    (1)\n)\n(select *\nfrom r )\nunion  all\n(select *\nfrom s)\n\n\n3 records\n\n\na\n\n\n\n\n1\n\n\n1\n\n\n1\n\n\n\n\n\nintersect all:\n\nwith r(a) as (\n    values\n    (1),\n    (1),\n    (1)\n), s(a) as (\n    values\n    (1),\n    (1)\n)\n(select *\nfrom r )\nINTERSECT all\n(select *\nfrom s)\n\n\n2 records\n\n\na\n\n\n\n\n1\n\n\n1\n\n\n\n\n\nexcept all:\n\nwith r(a) as (\n    values\n    (1),\n    (1)\n), s(a) as (\n    values\n    (1)\n)\n(select *\nfrom r )\nexcept  all\n(select *\nfrom s)\n\n\n1 records\n\n\na\n\n\n\n\n1\n\n\n\n\n\n\nwith r(a) as (\n    values\n    (1),\n    (1)\n), s(a) as (\n    values\n    (1)\n)\n(select *\nfrom s )\nexcept  all\n(select *\nfrom r)\n\n\n0 records\n\n\na"
  },
  {
    "objectID": "notes/03introSQL/introsql.html#null",
    "href": "notes/03introSQL/introsql.html#null",
    "title": "13  Introduction to SQL",
    "section": "13.5 Null",
    "text": "13.5 Null\n\nnull represents values that are not known. (can be anything).\narithmetic expressions involving null produce null:\n\n\nvalues\n(1 + null)\n\n\n1 records\n\n\ncolumn1\n\n\n\n\nNA\n\n\n\n\n\n\nboolean expressions and predicates involving null (other than is [not] null) have a special truth value unknown.\n\ne.g. (1 &lt; unknown) = uknown\n\ntruth tables for unknown:\n\n\n\n\np\nq\np and q\n\n\n\n\nfalse\nunknown\nfalse\n\n\ntrue\nunknown\nunknown\n\n\n\n\n\n\np\nq\np or q\n\n\n\n\nfalse\nunknown\nunknown\n\n\ntrue\nunknown\ntrue\n\n\n\nnot unknown = uknown\n\ntuples that evaluate to uknown in the where clause are not included in the result (just like the ones that evaluate to false)\nwe can test if a value is or isn’t null:\n\n\nselect a\nfrom (\n    values \n    (1, 3),\n    (2, null)\n) r(a, b)\nwhere b is null\n\n\n1 records\n\n\na\n\n\n\n\n2\n\n\n\n\n\n\nselect a\nfrom (\n    values \n    (1, 3),\n    (2, null)\n) r(a, b)\nwhere b is not null\n\n\n1 records\n\n\na\n\n\n\n\n1\n\n\n\n\n\n\nwe can test whether the result of a predicate is or isn’t uknown\n\n\nselect a\nfrom (\n    values \n    (1, 3),\n    (2, null)\n) r(a, b)\nwhere b &gt; 2 is unknown\n\n\n1 records\n\n\na\n\n\n\n\n2\n\n\n\n\n\n\nselect a\nfrom (\n    values \n    (1, 3),\n    (2, null)\n) r(a, b)\nwhere b &gt; 2 is not unknown\n\n\n1 records\n\n\na\n\n\n\n\n1"
  },
  {
    "objectID": "notes/03introSQL/introsql.html#aggregate-functions",
    "href": "notes/03introSQL/introsql.html#aggregate-functions",
    "title": "13  Introduction to SQL",
    "section": "13.6 Aggregate Functions",
    "text": "13.6 Aggregate Functions\n\nTake collection (i.e. aggregate, multiset) of values as input and return a single value.\nBuilt in aggregate functions in sql:\n\navg: input must be numeric\nmin\nmax\nsum: computes the total sum of the values in the aggregate, input must be numeric\ncount\n\n\n\n13.6.1 Basic Aggregation\n\nAverage salary of instructors in the CS department:\n\n\nselect avg(salary) as avg_salary\nfrom instructor \nwhere dept_name = 'Comp. Sci.'\n\n\n1 records\n\n\navg_salary\n\n\n\n\n77333.33\n\n\n\n\n\nDuplicates are retained. Retention of duplicates is obviously important for calculating averages. But sometimes we may want to eliminate duplicates:\n\nFind the total number of instructors that teach a course in the Spring 2018 semester:\n\n\nselect count(distinct t.instructor_id)\nfrom teaches t\nwhere semester = 'Spring' and year = 2018\n\n\n1 records\n\n\ncount\n\n\n\n\n6\n\n\n\n\n\nas opposed to\n\nselect count(t.instructor_id)\nfrom teaches t\nwhere semester = 'Spring' and year = 2018\n\n\n1 records\n\n\ncount\n\n\n\n\n7\n\n\n\n\n\n\ncounting all attributes with count(*):\n\n\nselect count(*)\nfrom course\n\n\n1 records\n\n\ncount\n\n\n\n\n13\n\n\n\n\n\ncount(*) retains null values. It is the only aggregate function that does so. All other aggregate functions ignore null values, including count functions applied on a single attribute. That is count(*) and count(attr) are different:\n\nselect count(*) as count_star, count(a) as count_attribute\nfrom (\n    values \n    (1),\n    (null)\n) r(a)\n\n\n1 records\n\n\ncount_star\ncount_attribute\n\n\n\n\n2\n1\n\n\n\n\n\n\n\n13.6.2 Aggregation with Grouping\nInstead of applying the aggregate function to a single aggregate (collection), we can apply it to multiple aggregates/collections, that consist of tuples grouped together w.r.t certain grouping attributes:\n\nfind the average salary in each department:\n\n\nselect dept_name, avg(salary) as avg_dept_salary\nfrom instructor  \ngroup by dept_name\norder by avg(salary) desc\n\n\n7 records\n\n\ndept_name\navg_dept_salary\n\n\n\n\nPhysics\n91000.00\n\n\nFinance\n85000.00\n\n\nElec. Eng.\n80000.00\n\n\nComp. Sci.\n77333.33\n\n\nBiology\n72560.00\n\n\nHistory\n59666.67\n\n\nMusic\n40000.00\n\n\n\n\n\n\nfind number of instructors working in each department:\n\n\nselect dept_name, count(*) cnt\nfrom instructor \ngroup by dept_name \norder by dept_name\n\n\n7 records\n\n\ndept_name\ncnt\n\n\n\n\nBiology\n2\n\n\nComp. Sci.\n3\n\n\nElec. Eng.\n1\n\n\nFinance\n2\n\n\nHistory\n3\n\n\nMusic\n2\n\n\nPhysics\n2\n\n\n\n\n\n\nfind the number of instructors in each department who teach a course in the Spring 2018 semester:\n\n\nselect i.dept_name, count(distinct i.id) as instr_count\nfrom instructor i , teaches t \nwhere i.id = t.instructor_id \nand t.semester = 'Spring' and t.year = 2018\ngroup by i.dept_name\n\n\n4 records\n\n\ndept_name\ninstr_count\n\n\n\n\nComp. Sci.\n3\n\n\nFinance\n1\n\n\nHistory\n1\n\n\nMusic\n1\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nNote that only attributes allowed to appear in the select clause (other than the attribute being aggregated) are the attributes used in the group by clause. Thus\nselect a, X, avg(b) -- X doesn't appear in the group by clause below\nfrom r -- some relation r\nwhere P -- some predicate\ngroup by a\nit not legal.\n\n\n\n\n13.6.3 Having Clause\nSpecifies a condition that applies to groups rather than to tuples.\n\ndepartments where average salayr is morethan $42,000:\n\n\nselect i.dept_name, avg(i.salary)\nfrom instructor i \ngroup by dept_name\nhaving avg(i.salary) &gt; 42000\norder by avg(i.salary) desc\n\n\n6 records\n\n\ndept_name\navg\n\n\n\n\nPhysics\n91000.00\n\n\nFinance\n85000.00\n\n\nElec. Eng.\n80000.00\n\n\nComp. Sci.\n77333.33\n\n\nBiology\n72560.00\n\n\nHistory\n59666.67\n\n\n\n\n\nLike with select the attributes that are allowed in the having clause are either present in the group by clause, it is the attribute that is being aggregated.\n\n\n13.6.4 Semantics of Group by and Having\nCan be understood roughly as:\n\nfrom is evaluated to get a relation\nwhere predicate is applied on each tupel to get a new relation\ntupels that agree on values of those attributes listed in the group by clause are placed into groups.\nhaving clause applied to each group, the ones that satisfy it are retianed to obtain a new relation\nselect clause is applied to the relation to obtain the resulting relation.\n\nA query with both where and having:\n\nfor each course section offered in 2017, find the average total credits (tot_cred) of all students enrolled in the section, if the section has at least 2 students:\n\n\nselect t.course_id, t.sec_id, t.semester, avg(s.tot_cred)\nfrom takes t, student s \nwhere t.student_id = s.id \nand t.\"year\" = 2017\ngroup by course_id, sec_id, semester\nhaving count(s.id) &gt; 1;\n\n\n3 records\n\n\ncourse_id\nsec_id\nsemester\navg\n\n\n\n\nCS-101\n1\nFall\n65\n\n\nCS-190\n2\nSpring\n43\n\n\nCS-347\n1\nFall\n67\n\n\n\n\n\n\n\n\n\n\n\nAggregation with null\n\n\n\nAll aggregate functions except of count(*) ignore null values\n\n\n\n\n\n\n\n\nAggregation of Boolean Values\n\n\n\n\nthe aggregate function some() can be applied to an aggregate consisting of boolean values to compute the disjunction of these values\nthe aggregate function every() can be applied to an aggregate consisting of boolean values to compute the conjunction of the values:\n\n\nselect every(a)\nfrom (\n    values \n    (true),\n    (true)\n) r(a)\n\n\n1 records\n\n\nevery\n\n\n\n\nTRUE"
  },
  {
    "objectID": "notes/03introSQL/introsql.html#nested-subqueries",
    "href": "notes/03introSQL/introsql.html#nested-subqueries",
    "title": "13  Introduction to SQL",
    "section": "13.7 Nested Subqueries",
    "text": "13.7 Nested Subqueries\nNested subqueries are used for:\n\ntest for set membership with [not] in\nmake set comparisons\ndetermine set cardinality by nesting queries in the where clause\n\nQueries can be nested in the\n\nwhere clause\nfrom clause\n\nSimple example for a subquery:\n\n-- names of departments and the average pay\n-- where average pay in that department is above the overall average pay\nselect dept_name, avg(i.salary) as avg_dep_pay\nfrom instructor i \ngroup by i.dept_name \nhaving avg(i.salary) &gt; (\n    select avg(i2.salary)\n    from instructor i2 \n)\norder by avg(i.salary) desc\n\n\n4 records\n\n\ndept_name\navg_dep_pay\n\n\n\n\nPhysics\n91000.00\n\n\nFinance\n85000.00\n\n\nElec. Eng.\n80000.00\n\n\nComp. Sci.\n77333.33\n\n\n\n\n\n\n13.7.1 Testing for Set Membership\nReconsider the queries\n\nFind all the courses taught in both Fall 2017 and Spring 2018 semesters\nFind all the courses taught in Fall 2017 but not in Spring 2018\n\nPreviously we used set operations. Now we can use in:\n\nselect distinct s.course_id  \nfrom \"section\" s \nwhere s.semester = 'Fall' and s.\"year\" = 2017 \nand s.course_id in (\n    select s.course_id\n    from \"section\" s \n    where s.semester = 'Spring' and s.\"year\" = 2018\n)\n\n\n1 records\n\n\ncourse_id\n\n\n\n\nCS-101\n\n\n\n\n\n\nselect distinct s.course_id  \nfrom \"section\" s \nwhere s.semester = 'Fall' and s.\"year\" = 2017 \nand s.course_id not in (\n    select s.course_id\n    from \"section\" s \n    where s.semester = 'Spring' and s.\"year\" = 2018\n)\n\n\n2 records\n\n\ncourse_id\n\n\n\n\nCS-347\n\n\nPHY-101\n\n\n\n\n\nwhere\nselect course_id\nfrom section\nwhere semester = 'Spring' and year = 2018\nis a nested subquery.\n\ndistinct is used since set operations remove duplicates by default.\n\n\n\n13.7.2 Enumerated Sets\n[not] in can be used on enumerated sets:\n\nNames of al instructors other than Mozart and Einstein:\n\n\nselect distinct name\nfrom instructor i \nwhere name not in ('Mozart', 'Einstein')\n\n\nDisplaying records 1 - 10\n\n\nname\n\n\n\n\nSingh\n\n\nSrinivasan\n\n\nCrick\n\n\nGreen\n\n\nBrandt\n\n\nGold\n\n\nRoznicki\n\n\nCalifieri\n\n\nWu\n\n\nKim\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nenumerated sets shouldn’t be confused with tupels\n\n\n\n\n13.7.3 Set Comparison\nReconsider the query:\n\nNames of all instructors whose salary is grater than at least one instructor in the Biology department:\n\nPreviously we used the somewhat awkward solution:\nselect i.name\nfrom instructor i , instructor i2 \nwhere i2.dept_name = 'Biology'\nand i.salary &gt; i2.salary \nNow we can express this much more similar to natural language:\n\nselect i.name\nfrom instructor i \nwhere i.salary &gt; some(\n    select salary \n    from instructor\n    where dept_name = 'Biology'\n)\n\n\n8 records\n\n\nname\n\n\n\n\nWu\n\n\nEinstein\n\n\nGold\n\n\nKatz\n\n\nSingh\n\n\nBrandt\n\n\nKim\n\n\nNishimoto\n\n\n\n\n\nContrast:\n\n\n\n\n\n\n\nwith cross product\nwith set comparison\n\n\n\n\nselect i.name\nfrom instructor i , instructor i2\nwhere i2.dept_name = 'Biology'\nand i.salary &gt; i2.salary\nselect i.name\nfrom instructor i\nwhere i.salary &gt; some(\n    select salary\n    from instructor\n    where dept_name = 'Biology'\n)\n\n\n\nConsider another query:\n\nNames of instructors that have a salary greater than that of any/each instructor in the Biology department:\n\n\nselect i.\"name\"\nfrom instructor i \nwhere i.salary &gt; all (\n    select salary \n    from instructor \n    where dept_name = 'Biology'\n)\n\n\n7 records\n\n\nname\n\n\n\n\nWu\n\n\nEinstein\n\n\nGold\n\n\nKatz\n\n\nSingh\n\n\nBrandt\n\n\nKim\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\n\n= some (...) is identical to in (...)\n&lt;&gt; some (...) is not identical to not in (...)\n&lt;&gt; all (...) is identical to not in (...)\n= all(...) is not identical to in (...)\n\n\n\n\nname of the department with the highest average salary:\n\n\nselect dept_name\nfrom instructor i \ngroup by i.dept_name\nhaving avg(i.salary) &gt;= all (\n    select avg(salary)\n    from instructor \n    group by dept_name \n)\n\n\n1 records\n\n\ndept_name\n\n\n\n\nPhysics\n\n\n\n\n\n\n\n13.7.4 Testing for Empty Relations\nWe can test whether a query has any tuples in its result (whether if it’s non-empty) with exists. Reconsider the query\n\nAll courses taught both in the Fall 2017 and Spring 2018:\n\n\nselect course_id \nfrom \"section\" s\nwhere s.semester = 'Fall' and s.\"year\" = 2017\nand exists (\n    select *\n    from \"section\" s2\n    where s2.semester = 'Spring' and s2.\"year\" = 2018\n    and s.course_id = s2.course_id \n)\n\n\n1 records\n\n\ncourse_id\n\n\n\n\nCS-101\n\n\n\n\n\nAbove a correlation name from the outer querry has been used in the inner querry. This can equivalently be achieved with a usual join operation:\nselect s.course_id\nfrom \"section\" s , \"section\" s2\nwhere s.semester = 'Fall' and s.\"year\" = 2017\nand s2.semester = 'Spring' and s2.\"year\" = 2018\nand s.course_id = s2.course_id \nNon-existence can be queried with not exists. For example we can use it to simulate set containment.\n\\[ B \\subseteq A \\equiv \\texttt{not exists (B except A)} \\]\n\nAll students who have taken all courses offered in the Biology department:\n\n\nselect s.id, s.\"name\" \nfrom student s \nwhere not exists (\n    (select c.id\n    from course c\n    where c.dept_name = 'Biology')\n        except\n    (select t.course_id \n    from takes t \n    where s.id = t.course_id)\n)\n\n\n0 records\n\n\nid\nname\n\n\n\n\n\n\n\nThe subquerry\nselect c.id\nfrom course c\nwhere c.dept_name = 'Biology'\nfinds all courses offered in the Biology department. The subquerry:\nselect t.course_id \nfrom takes t \nwhere s.id = t.course_id\nfinds all courses that the student ‘s’ has taken.\nConsider the query:\n\nHow many students have taken a course by instructor with the ID ‘10101’\n\nWe can construct this query in three different ways:\n\nWith the usual join operation:\n\nselect count(distinct t.student_id)\nfrom takes t, teaches t2 \nwhere t.course_id = t2.course_id \n    and t.sec_id = t2.sec_id \n    and t.semester = t2.semester \n    and t.\"year\" = t2.\"year\" \n    and t2.instructor_id = '10101'\n\nWith set membership test using in with a tuple instead of a single attribute\n\nselect count(distinct t.student_id)\nfrom takes t \nwhere (t.course_id, t.sec_id, t.semester, t.\"year\") in ( \n    select t2.course_id , t2.sec_id , t2.semester , t2.\"year\" \n    from teaches t2 \n    where t2.instructor_id = '10101'\n)\n\nwith the exists construct\n\n\nselect count(distinct t.student_id)\nfrom takes t \nwhere exists (\n    select t2.course_id , t2.sec_id , t2.semester , t2.\"year\" \n    from teaches t2 \n    where t.course_id = t2.course_id \n    and t.sec_id = t2.sec_id \n    and t.semester = t2.semester \n    and t.\"year\" = t2.\"year\" \n    and t2.instructor_id = '10101'\n)\n\n\n1 records\n\n\ncount\n\n\n\n\n6\n\n\n\n\n\n\n\n13.7.5 Test for Absence of Duplicates / Test for Uniqueness\nTesting if subquery has duplicate tuples with unique:\n\ncourses that were offered at most once in 2017:\n\nselect c.id \nfrom course c \nwhere unique (\n    select \n    from \"section\" s \n    where c.id = s.course_id \n    and s.\"year\" = 2017\n)\nSince unique not implemented in Postgresql, we can simulate it as follows:\n\nselect c.id \nfrom course c \nwhere 1 &gt;= (\n    select count(s.course_id)\n    from \"section\" s \n    where s.\"year\" = 2017\n    and c.id = s.course_id\n)\n\n\nDisplaying records 1 - 10\n\n\nid\n\n\n\n\nBIO-101\n\n\nBIO-301\n\n\nBIO-399\n\n\nCS-101\n\n\nCS-315\n\n\nCS-319\n\n\nCS-347\n\n\nEE-181\n\n\nFIN-201\n\n\nHIS-351\n\n\n\n\n\n(For some reason this delivers a different result than two solutions below. Why?)\nAnother solution using aggregate functions:\n\nselect c.id \nfrom course c , \"section\" s \nwhere c.id = s.course_id \nand s.\"year\" = 2017\ngroup by c.id\nhaving count(*) &lt;= 1\n\n\n5 records\n\n\nid\n\n\n\n\nBIO-101\n\n\nCS-101\n\n\nCS-347\n\n\nEE-181\n\n\nPHY-101\n\n\n\n\n\nYet another far less elegant solution:\n\nFirst we find courses offered more than once in 2017:\n\n\nselect course_id\nfrom \"section\" s \nwhere s.\"year\" = 2017\n    except all\nselect distinct course_id \nfrom \"section\" s \nwhere s.\"year\" = 2017\n\n\n1 records\n\n\ncourse_id\n\n\n\n\nCS-190\n\n\n\n\n\n\nThan courses offered at most once in 2017:\n\n\nselect distinct course_id\nfrom \"section\" s \nwhere s.\"year\" = 2017\nand course_id not in (\n    select course_id\nfrom \"section\" s \nwhere s.\"year\" = 2017\n    except all\nselect distinct course_id \nfrom \"section\" s \nwhere s.\"year\" = 2017\n)\n\n\n5 records\n\n\ncourse_id\n\n\n\n\nBIO-101\n\n\nCS-101\n\n\nCS-347\n\n\nEE-181\n\n\nPHY-101\n\n\n\n\n\n\n\n13.7.6 Subqueries in the From Clause\nSince relations appear in the from clause, there is nothing preventing them being subqueries. Reconsider the query\n\nAverage instructor salaries per department, where the average salary in that department is greater than 42000:\n\nPreviously we solved using group by and having - which is the natural way:\nselect i.dept_name, avg(i.salary) avg_salary\nfrom instructor i \ngroup by i.dept_name \nhaving avg(i.salary) &gt; 42000\nWe can re-write it without having using subquery in the from clause:\n\nselect dept_name, avg_salary\nfrom (\n    select i.dept_name, avg(i.salary)\n    from instructor i \n    group by i.dept_name \n) dep_salaries(dept_name, avg_salary) --table alias \nwhere avg_salary &gt; 42000\n\n\n6 records\n\n\ndept_name\navg_salary\n\n\n\n\nPhysics\n91000.00\n\n\nBiology\n72560.00\n\n\nElec. Eng.\n80000.00\n\n\nFinance\n85000.00\n\n\nComp. Sci.\n77333.33\n\n\nHistory\n59666.67\n\n\n\n\n\nContrast:\n\n\n\n\n\n\n\nwith having\nwith nested query in from clause\n\n\nselect i.dept_name, avg(i.salary) avg_salary\nfrom instructor i\ngroup by i.dept_name\nhaving avg(i.salary) &gt; 42000\nselect dept_name, avg_salary\nfrom (\n    select i.dept_name, avg(i.salary)\n    from instructor i\n    group by i.dept_name\n) dep_salaries(dept_name, avg_salary) --table alias\nwhere avg_salary &gt; 42000\n\n\n\nAnother example:\n\nmax total salary in a department across all departments:\n\n\nselect max(tot_sal) as max_tot_sal\nfrom (\n    select sum(i.salary)\n    from instructor i \n    group by i.dept_name \n) r(tot_sal) -- table alias\n\n\n1 records\n\n\nmax_tot_sal\n\n\n\n\n232000\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nCorrelation variables are allowed in a from subquery using the lateral keyword.\n\nnames of instructors, their salaries, alongside with the average salary of their department:\n\n\nselect i.name, i.salary , i.dept_name, avg_dep_salary\nfrom instructor i , lateral (\n    select avg(i2.salary)\n    from instructor i2 \n    where i.dept_name = i2.dept_name \n) r(avg_dep_salary)\n\n\nDisplaying records 1 - 10\n\n\nname\nsalary\ndept_name\navg_dep_salary\n\n\n\n\nSrinivasan\n65000\nComp. Sci.\n77333.33\n\n\nWu\n90000\nFinance\n85000.00\n\n\nMozart\n40000\nMusic\n40000.00\n\n\nEinstein\n95000\nPhysics\n91000.00\n\n\nEl Said\n60000\nHistory\n59666.67\n\n\nGold\n87000\nPhysics\n91000.00\n\n\nKatz\n75000\nComp. Sci.\n77333.33\n\n\nCalifieri\n62000\nHistory\n59666.67\n\n\nSingh\n80000\nFinance\n85000.00\n\n\nCrick\n72000\nBiology\n72560.00\n\n\n\n\n\n\n\n\n\n13.7.7 With Clause\nDefines temporary relations whose definition is available only in the query in which with clause occurs.\n\nDepartments with maximum budget\n\n\nwith max_budget(value) as (\n    select max(d.budget)\n    from department d \n)\nselect d.\"name\" , d.budget as budget\nfrom department d, max_budget mb\nwhere d.budget = mb.value \n\n\n1 records\n\n\nname\nbudget\n\n\n\n\nFinance\n120000\n\n\n\n\n\nAlternatively we can use nested subquerries in the with clause or in the from clause:\n\nas a simple subquery in where clause:\n\nselect d.\"name\" , d.budget \nfrom department d \nwhere d.budget = (\n    select max(d2.budget)\n    from department d2 \n)\n\nusing all with a where-clause subquery:\n\nselect d.name, d.budget  \nfrom department d \nwhere d.budget &gt;= all (\n    select budget \n    from department d2 \n)\n\nas from-clause subquery:\n\nselect d.name, d.budget \nfrom department d, (\n    select max(d2.budget)\n    from department d2 \n) bd(val)\nwhere d.budget = bd.val\nUsing with improves readability. Consider another example:\n\ndepartments where total salary greater than the average of the total salary of all departments:\n\n\nwith dep_tot_salary(d_name, t_salary) as (\n    select i.dept_name, sum(i.salary)\n    from instructor i \n    group by i.dept_name    \n)\nselect *\nfrom dep_tot_salary\nwhere t_salary &gt; (\n    select avg(t_salary)\n    from dep_tot_salary\n)\n\n\n4 records\n\n\nd_name\nt_salary\n\n\n\n\nPhysics\n182000\n\n\nFinance\n170000\n\n\nComp. Sci.\n232000\n\n\nHistory\n179000\n\n\n\n\n\n\n\n13.7.8 Scalar Subqueries\nQueries returning one single tuple with one attribute are called scalar. Such queries can be used in place of values as scalar subquerries, even in select-clause:\n\nall departments along with number of instructors in each department\n\n\nselect d.\"name\" , \n       ( -- scalare unteranfragen duerfen innerhalb select eingesetzt werden\n        select count(*)\n        from instructor i \n        where d.\"name\" = i.dept_name --d is a correlatin variable\n       ) cnt\nfrom department d \norder by cnt desc\n\n\n7 records\n\n\nname\ncnt\n\n\n\n\nHistory\n3\n\n\nComp. Sci.\n3\n\n\nFinance\n2\n\n\nBiology\n2\n\n\nPhysics\n2\n\n\nMusic\n2\n\n\nElec. Eng.\n1\n\n\n\n\n\nOf course this can simply be achieved with grouping:\n\nselect i.dept_name , count(*)\nfrom instructor i \ngroup by i.dept_name \norder by count(*) desc\n\n\n7 records\n\n\ndept_name\ncount\n\n\n\n\nHistory\n3\n\n\nComp. Sci.\n3\n\n\nPhysics\n2\n\n\nFinance\n2\n\n\nBiology\n2\n\n\nMusic\n2\n\n\nElec. Eng.\n1\n\n\n\n\n\nAlternatively as subquery of from with lateral:\nselect d.\"name\", res.val as cnt\nfrom department d , lateral (\n    select count(*)\n    from instructor i \n    where i.dept_name = d.\"name\" \n) res(val)\norder by cnt desc\nScalar subqueries can occur in select, where and having clauses.\n\n\n13.7.9 Queries Without From\n\nwith values\n\n\nvalues\n(1, 'a'),\n(2, 'b')\n\n\n2 records\n\n\ncolumn1\ncolumn2\n\n\n\n\n1\na\n\n\n2\nb\n\n\n\n\n\n\nwith select\n\n\nselect \n(1), ('a')\n  union all\nselect \n(2), ('b')\n\n\n2 records\n\n\n?column?\n?column?..2\n\n\n\n\n1\na\n\n\n2\nb"
  },
  {
    "objectID": "notes/03introSQL/introsql.html#modifying-the-database",
    "href": "notes/03introSQL/introsql.html#modifying-the-database",
    "title": "13  Introduction to SQL",
    "section": "13.8 Modifying the Database",
    "text": "13.8 Modifying the Database\n\nadding - insert into R\nremoving - delete from R\nchanging - update R set\n\ninfromation from the database as opposed to querying.\n\n13.8.1 Deletion\nExpressed just like a query,\n\ndelete tuples from r satisfying condition P:\n\ndelete from r -- relation\nwhere P -- predicate\n\ndelete all tuples from instructor:\n\ndelete from instructor;\nor equivalently\ndelete from instructor\nwhere true\nThe predicate can be arbitrarily complex,\n\nDelete all instructors that work in the Watson building:\n\ndelete from instructor\nwhere dept_name in (\n  select dept_name\n  from department\n  where building = 'Watson'\n)\ndelete deletes tupels from a single relation, but we can still reference any number of relations nested in select, from and where, including the one that we are deleting from. Consider:\n\ndelete all instructors that earn less than the overall average instructor salary\n\ndelete from instructor\nwhere salary &lt; (\n  select avg(salary)\n  from instructor\n)\n\ndelete(which is anoter way of saying ‘fire’) all instructors that haven’t taught in the year 2018\n\ndelete from instructor i\nwhere i.id not in (\n  select t.instructor_id\n  from teaches t \n  where t.\"year\" = 2018\n)\nabove a relation other than the one being deleted was referenced in the nested subquery in the where clause, demonstrating we can reference arbitrary relations.\n\n\n\n\n\n\nNote\n\n\n\ndeletions are performed after the tupels are filtered (the ones that pass the test). Otherwise the result could be influenced.\n\n\n\n\n13.8.2 Insertion\nAny query result delivering a collection of tuples can be inserted into a relation, as long as they agree with the cardinality and domains of the attributes of the relation:\n\nproviding tuples explicitetly using values:\n\ninsert into course\nvalues \n('CS-437', 'Database Systems', 'Comp. Sci.', 4),\n('PHY-201', 'Intro. Theo. Phys.', 'Physics', 6)\n\nor using select:\n\ninsert into course\nselect \n('CS-437'), ('Database Systems'), ('Comp. Sci.'), (4)\n  union\nselect \n('PHY-201'), ('Intro. Theo. Phys.'), ('Physics'), (6)\n\nwe can explicitely specify the order of the attributes:\n\ninsert into course(title, id, credits, dept_name)\n  values ('Database Systems', 'CS-437', 4, 'Comp. Sci.')\n\neven omit some of the attributes from the specification (ommited attributes are set automatically as null):\n\ninsert into course (title, id)\n  values ('Baking Cakes', 'BK-101')\nAbove dept_name and credit are set automatically as null.\nMore generally, results of an arbitary query can be inserted as well. Consider:\n\nmake each student in the Music department who has earned more than 144 credit hours an instructor in the Music department with a salary of $18,000.\n\ninsert into instructor \n  select s.id, s.\"name\", s.dept_name, 18000\n  from student s\n  where s.dept_name = 'Music' and tot_cred &gt; 144;\n\ninsert a copy of a relation to itself:\n\ninsert into s\n  select *\n  from s\n\n\n\n\n\n\nNote\n\n\n\nImportantly in the above example:\ninsert into s\n  select *\n  from s\nthe query is evaluated before the insertion is performed. Otherwise we could face infinite loops. Also note that this operation is only possible if the relation s has no primary key defined. Otherwise duplicates are not allowed.\n\n\n\n\n13.8.3 Updates\nChanging some values of tuples is possible with update. Consider:\n\nIncrease the salaries of all instructors by 5%\n\nupdate instructor\nset salary = salary * 1.05\n\nRaise the salary only of those instructors with pay less than $70,000\n\nupdate instructor\nset salary = salary * 1.05\nwhere salary &lt; 70000\nNested subqueries are allowed in the where clause, referencing the relation being updated or other arbitrary relations. Consider:\n\ngive a 5% salary raise to instructors whose salary is less than overall average salary:\n\nupdate instructor\nset salary = salary * 1.05\nwhere salary &lt; (\n  select avg(salary)\n  from instructor \n)\n\ngive a 5% salary raise to instructors that have taugh more than 1 course in 2018:\n\nupdate instructor i\nset i.salary = i.salary * 1.05\nwhere 1 &lt; (\n    select count(*)\n    from teaches t \n    where t.instructor_id = i.id\n    and  t.\"year\" = 2018\n)\n\ngive 3% raise to instructors with salary over $100,000, 5% to others.\n\nOne solution is to write to update statements:\nupdate instructor \nset salary = salary * 1.03\nwhere salary &gt; 100000\nupdate instructor \nset salary = salary * 1.05\nwhere salary &lt;= 100000\n\n\n\n\n\n\nWarning\n\n\n\nin the above solution the order of statements is important, otherwise we could end up giving a 8% raise to instructors whose salary is 100000 or just below it.\n\n\nAlternatively use case statement. Then the order won’t be important.\nupdate instructor\nset salary = \n  case\n    when salary &lt;= 100000 then salary * 1.05\n    else salary * 1.03\n  end \n\n\n\n\n\n\nNote\n\n\n\nGeneral syntax of case statement:\ncase \n  when P1 then res1 -- P1 is a predicate \n  when P2 then res2 \n  ...\n  when Pn then res_n\n  else res0\nend\nsince case statement is an expression that is evaluated to a value, it can be used any place where a value is used.\n\n\nComplex subqueries can follow after set clause:\n\nset total credit of each student to the sum of the credits of courses successfully completed by the student. (Grade is not an ‘F’ or null)\n\nupdate student\nset tot_cred = (\n    select sum(c.credits)\n    from takes t, course c\n    where t.course_id = c.id \n        and t.student_id = student.id \n        and t.grade is not null \n        and t.grade not like 'F'\n)\nFor student that haven’t successfully completed a course, total credit will be set to null. Instead we may set it to 0 using case:\nupdate student\nset tot_cred = (\n  case\n    when select sum(c.credits) is not null then sum(credits)\n    else 0\n    from takes t, course c\n    where t.course_id = c.id \n        and t.student_id = student.id \n        and t.grade is not null \n        and t.grade not like 'F'\n)\nEquivalently, this can be ahieved by coalesce provided by some DBs.\nupdate student\nset tot_cred = (\n    select coalesce(sum(c.credits), 0)\n    from takes t, course c\n    where t.course_id = c.id \n        and t.student_id = student.id \n        and t.grade is not null \n        and t.grade not like 'F'\n)\nwhere coalesce(x, y) evaluates to x, if x is not null, and to y otherwise."
  },
  {
    "objectID": "notes/04interSQL/intersql.html#join-expressions",
    "href": "notes/04interSQL/intersql.html#join-expressions",
    "title": "14  Intermediate SQL",
    "section": "14.1 Join Expressions",
    "text": "14.1 Join Expressions\n\n14.1.1 Natural join\ncorresponds to \\(\\bowtie\\). Consider:\n\nselect *\nfrom (\n    values \n    (1, 2),\n    (3, 2)\n) r(a, b) natural join\n(\n    values \n    (2, 3),\n    (2, 4),\n    (1, 10),\n    (5, 8)\n) s(b, c)\n\n\n4 records\n\n\nb\na\nc\n\n\n\n\n2\n3\n3\n\n\n2\n1\n3\n\n\n2\n3\n4\n\n\n2\n1\n4\n\n\n\n\n\n\n\n14.1.2 Join Using\nPossible to explicitely list attributes on which it is to be joined:\n\nselect *\nfrom (\n    values \n    (1, 2, 5),\n    (3, 2, 7)\n) r(a, b, c) join\n(\n    values \n    (2, 3),\n    (2, 4),\n    (1, 10),\n    (5, 8)\n) s(b, c) using (b)\n\n\n4 records\n\n\nb\na\nc\nc..4\n\n\n\n\n2\n3\n7\n3\n\n\n2\n1\n5\n3\n\n\n2\n3\n7\n4\n\n\n2\n1\n5\n4\n\n\n\n\n\nsame as\nselect *\nfrom r, s\nwhere r.b = s.b\n\n\n14.1.3 Join on\n\nselect *\nfrom student join takes on student.id = takes.student_id\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nid\nname\ndept_name\ntot_cred\nstudent_id\ncourse_id\nsec_id\nsemester\nyear\ngrade\n\n\n\n\n00128\nZhang\nComp. Sci.\n102\n00128\nCS-101\n1\nFall\n2017\nA\n\n\n00128\nZhang\nComp. Sci.\n102\n00128\nCS-347\n1\nFall\n2017\nA-\n\n\n12345\nShankar\nComp. Sci.\n32\n12345\nCS-101\n1\nFall\n2017\nC\n\n\n12345\nShankar\nComp. Sci.\n32\n12345\nCS-190\n2\nSpring\n2017\nA\n\n\n12345\nShankar\nComp. Sci.\n32\n12345\nCS-315\n1\nSpring\n2018\nA\n\n\n12345\nShankar\nComp. Sci.\n32\n12345\nCS-347\n1\nFall\n2017\nA\n\n\n19991\nBrandt\nHistory\n80\n19991\nHIS-351\n1\nSpring\n2018\nB\n\n\n23121\nChavez\nFinance\n110\n23121\nFIN-201\n1\nSpring\n2018\nC+\n\n\n44553\nPeltier\nPhysics\n56\n44553\nPHY-101\n1\nFall\n2017\nB-\n\n\n45678\nLevy\nPhysics\n46\n45678\nCS-101\n1\nFall\n2017\nF\n\n\n\n\n\nExactly the same as\nselect *\nfrom student, takes\nwhere student.id = takes.student_id\nAdvantages:\n\nreadability in separating join conditions from other where-clause conditions\nnecessary for outer joins.\n\n\n\n14.1.4 Outer Joins\nAccording to the definition of usual join operation\nselect *\nfrom student join takes\non student.id = takes.student_id\nnon-matched tuples don’t appear in the resulting relation. But sometimes we might nevertheless wich to include such tuples in the result.\nThis can be achieved by\n\nleft outer join\nright outer join\nfull outer join\n\nFirst of all, notice that there is one student who hasn’t taken any courses:\n\nselect *\nfrom student s \nwhere s.id not in (\n    select t.student_id \n    from takes t \n)\n\n\n2 records\n\n\nid\nname\ndept_name\ntot_cred\n\n\n\n\n70557\nSnow\nPhysics\n0\n\n\n12789\nNewman\nComp. Sci.\nNA\n\n\n\n\n\nAn he doesn’t appear in the previous join operation. We can include this student in the final result using left outer join:\n\nselect *\nfrom student s left outer join takes t \non s.id = t.student_id \norder by s.id desc\n\n\nDisplaying records 1 - 10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nid\nname\ndept_name\ntot_cred\nstudent_id\ncourse_id\nsec_id\nsemester\nyear\ngrade\n\n\n\n\n98988\nTanaka\nBiology\n120\n98988\nBIO-301\n1\nSummer\n2018\nNA\n\n\n98988\nTanaka\nBiology\n120\n98988\nBIO-101\n1\nSummer\n2017\nA\n\n\n98765\nBourikas\nElec. Eng.\n98\n98765\nCS-101\n1\nFall\n2017\nC-\n\n\n98765\nBourikas\nElec. Eng.\n98\n98765\nCS-315\n1\nSpring\n2018\nB\n\n\n76653\nAoi\nElec. Eng.\n60\n76653\nEE-181\n1\nSpring\n2017\nC\n\n\n76543\nBrown\nComp. Sci.\n58\n76543\nCS-319\n2\nSpring\n2018\nA\n\n\n76543\nBrown\nComp. Sci.\n58\n76543\nCS-101\n1\nFall\n2017\nA\n\n\n70557\nSnow\nPhysics\n0\nNA\nNA\nNA\nNA\nNA\nNA\n\n\n55739\nSanchez\nMusic\n38\n55739\nMU-199\n1\nSpring\n2018\nA-\n\n\n54321\nWilliams\nComp. Sci.\n54\n54321\nCS-101\n1\nFall\n2017\nA-\n\n\n\n\n\nNotice how the tuple corresponding to student Snow who hasn’t taken any courses has null values for all attributes that come from the takes relation.\nConsider a simpler exampe. Consider tables:\n\nwith r(a, b) as (\n    values \n    (1, 2),\n    (2, 2),\n    (5, 3)\n), s(b, c) as (\n    values\n    (2, 4),\n    (2, 5)\n) \nselect *\nfrom r natural join s \n\n\n4 records\n\n\nb\na\nc\n\n\n\n\n2\n1\n5\n\n\n2\n1\n4\n\n\n2\n2\n5\n\n\n2\n2\n4\n\n\n\n\n\nAbove natural join didn’t include the tuple (5, 3) from r, since it didn’t match with anything from s. But\n\nwith r(a, b) as (\n    values \n    (1, 2),\n    (2, 2),\n    (5, 3)\n), s(b, c) as (\n    values\n    (2, 4),\n    (2, 5)\n) \nselect r.a a, r.b b, s.c c\nfrom r natural left outer join s\n\n\n5 records\n\n\na\nb\nc\n\n\n\n\n1\n2\n5\n\n\n1\n2\n4\n\n\n2\n2\n5\n\n\n2\n2\n4\n\n\n5\n3\nNA\n\n\n\n\n\ncontains tuple (5, 3, null).\ninner join is just another name for all other default joins that don’t include nonmatched tuples.\nAlternative way to find students that haven’t taken a course using outer join:\n\nselect * \nfrom student s left outer join takes t \non s.id = t.student_id \nwhere t.course_id is null\n\n\n2 records\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nid\nname\ndept_name\ntot_cred\nstudent_id\ncourse_id\nsec_id\nsemester\nyear\ngrade\n\n\n\n\n70557\nSnow\nPhysics\n0\nNA\nNA\nNA\nNA\nNA\nNA\n\n\n12789\nNewman\nComp. Sci.\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n\n\n\n\n\nright outer join is symmetric to left outer join. Adding (4, 7) to s in the previous simple example:\n\nwith r(a, b) as (\n    values \n    (1, 2),\n    (2, 2),\n    (5, 3)\n), s(b, c) as (\n    values\n    (2, 4),\n    (2, 5),\n    (4, 7)\n) \nselect *\nfrom r natural right outer join s\n\n\n5 records\n\n\nb\na\nc\n\n\n\n\n2\n2\n4\n\n\n2\n1\n4\n\n\n2\n2\n5\n\n\n2\n1\n5\n\n\n4\nNA\n7\n\n\n\n\n\n(4, 7) didn’t match with any tuple from r but was still included in the result with a set null.\nfull outer join is a combination of left and right outer joins. Again the previous example:\n\nwith r(a, b) as (\n    values \n    (1, 2),\n    (2, 2),\n    (5, 3)\n), s(b, c) as (\n    values\n    (2, 4),\n    (2, 5),\n    (4, 7)\n) \nselect *\nfrom r natural full outer join s\n\n\n6 records\n\n\nb\na\nc\n\n\n\n\n2\n1\n5\n\n\n2\n1\n4\n\n\n2\n2\n5\n\n\n2\n2\n4\n\n\n3\n5\nNA\n\n\n4\nNA\n7\n\n\n\n\n\nAnotheer full outer join exmaple:\n\nall students from the Comp. Sci. department, along with course sections, if any that they have taken in Spring 2017; all course sections from Spring 2017 must be displayed even if no student from the Comp. Sci department has taken the course:\n\n\nselect s.id, t.course_id\nfrom ( -- subquery computing relation containing students from CS department\n    select s.id, s.name\n    from student s \n    where s.dept_name = 'Comp. Sci.'\n) s(id, name) right outer join \n( -- subquery computing relation of section taken in Spring 2017\n    select t.student_id, t.course_id, t.sec_id, t.semester, t.\"year\"\n    from takes t \n    where t.semester = 'Spring'\n        and t.year = 2017\n) t(id, course_id, sec_id, semester, year) on s.id = t.id\n\n\n3 records\n\n\nid\ncourse_id\n\n\n\n\n12345\nCS-190\n\n\n54321\nCS-190\n\n\nNA\nEE-181\n\n\n\n\n\nor an equivalent alternative formulation using with to factor the subqueries:\nwith s(id) as (\n    select s.id\n    from student s \n    where s.dept_name = 'Comp. Sci.' \n), t(id, sec_id, course_id, semester, year) as (\n    select t.student_id, t.sec_id, t.course_id , t.semester, t.\"year\" \n    from takes t \n    where t.semester = 'Spring' and t.\"year\" = 2017\n)\nselect s.id, t.course_id \nfrom s right outer join t on s.id = t.id\n\n\n\n\n\n\nWarning\n\n\n\nNote that\n\nselect s.id, t.course_id\nfrom student s right outer join takes t\non s.id = t.student_id \nwhere s.dept_name = 'Comp. Sci.'\n    and t.semester = 'Spring'\n    and t.\"year\" = 2017\n\n\n2 records\n\n\nid\ncourse_id\n\n\n\n\n12345\nCS-190\n\n\n54321\nCS-190\n\n\n\n\n\nwould be a wrong solution, since right outer join is performed before the where clause on the full student relation and not on the student relation restricted to the CS department.\n\n\nTo verify previous solution compute sections offered in Spring 2017:\n\nselect *\nfrom section \nwhere year = 2017\n    and semester = 'Spring'\n\n\n3 records\n\n\ncourse_id\nid\nsemester\nyear\nbuilding\nroom_number\ntime_slot_id\n\n\n\n\nCS-190\n1\nSpring\n2017\nTaylor\n3128\nE\n\n\nCS-190\n2\nSpring\n2017\nTaylor\n3128\nA\n\n\nEE-181\n1\nSpring\n2017\nTaylor\n3128\nC\n\n\n\n\n\nIndeed, course ‘EE-181’ hasn’t been taken by any student from the CS department."
  },
  {
    "objectID": "notes/04interSQL/intersql.html#views",
    "href": "notes/04interSQL/intersql.html#views",
    "title": "14  Intermediate SQL",
    "section": "14.2 Views",
    "text": "14.2 Views\nTwo reasons:\n\nSecurity; restricting what users can see\nVirtual tables that better correspond to the intuition of the user\n\nview can be thought of extending with beyond use in a single query. It is possible to define arbitrarily many views on top of existing relations.\n\n14.2.1 View Definition and Usage\nSyntax:\ncreate view v as &lt;query expression&gt;\nExamples:\n\nrestricted access to instuctor relation without salary information:\n\ncreate view faculty as\n    select i.id, i.\"name\" , i.dept_name \n    from instructor i \nThen, we can access faculty as if it were a regular relation:\n\nselect * \nfrom faculty f\n\n\nDisplaying records 1 - 10\n\n\nid\nname\ndept_name\n\n\n\n\n10101\nSrinivasan\nComp. Sci.\n\n\n12121\nWu\nFinance\n\n\n15151\nMozart\nMusic\n\n\n22222\nEinstein\nPhysics\n\n\n32343\nEl Said\nHistory\n\n\n33456\nGold\nPhysics\n\n\n45565\nKatz\nComp. Sci.\n\n\n58583\nCalifieri\nHistory\n\n\n76543\nSingh\nFinance\n\n\n76766\nCrick\nBiology\n\n\n\n\n\nIn authorization section we can see how users can be given access to views instead of or in addition to relations.\n\n\n\n\n\n\nNote\n\n\n\nview relations are not pre-computed and stored; they are computed dynamically.\n\n\n\nview of all course section offered by the physics department in fall 2017:\n\ncreate view physics_fall_2017 as \n    select c.id as course_id, s.id as section_id, s.building , s.room_number \n    from course c , \"section\" s \n    where c.id = s.course_id \n        and c.dept_name = 'Physics'\n        and s.\"year\" = 2017\n        and s.semester = 'Fall'\nViews remain available until explicitly dropped.\nExamples for usage of views:\n\nid of physics courses offered in Fall 2017 semester, Watson building:\n\n\nselect course_id\nfrom physics_fall_2017 \nwhere building = 'Watson'\n\n\n1 records\n\n\ncourse_id\n\n\n\n\nPHY-101\n\n\n\n\n\nAttribute names can be specified explicitly:\ncreate view departments_total_salary(dept_name, total_salary) as \n    select i.dept_name, sum(i.salary)\n    from instructor i \n    group by i.dept_name\nThen we can use it:\n\ndepartments with corresponding total salaries where total salary is less than the average total salary across departments:\n\n\nselect *\nfrom departments_total_salary dts\nwhere dts.total_salary &lt; (\n    select avg(total_salary)\n    from departments_total_salary\n)\n\n\n3 records\n\n\ndept_name\ntotal_salary\n\n\n\n\nBiology\n145120\n\n\nElec. Eng.\n80000\n\n\nMusic\n40000\n\n\n\n\n\nOne view may be used in defining another view.\n\nview listing id and room number of all physics courses offered in fall 2018 in the Watson building, using the previous view physics_fall_2017\n\ncreate view physics_fall_2017_watson as\n    select course_id, room_number\n    from physics_fall_2017 \n    where building = 'Watson'\n\n\n14.2.2 Materialized Views\nWe learned that results of views are not pre-computed and stored, i.e. they are simply virtual relations that are computed on demand. But some DBs allow storing pre-computed views, that are automatically updated when the relations used in the definition of the view change.\nSuch views are called materialized views.\nSome DB’s only periodically update materialized views, some perform updates when they are accessed. Some DBMS allow specifying which method is to be used.\nAdvantages of materialized views is avoiding recomputing the relation defined by the view each time it is accessed. It can be beneficial if the relations used in view definition are very large.\n\n\n14.2.3 Update of a View\nModifications are generally not allowed on views, since views usually represent partial information and inserting tuples into views would require inserting null values into original relations. Which is not guaranteed to work when the view is defined by joining multiple relations and the joined attribute is omitted form the final view definition.\nFollowing works in postgresql:\ninsert into faculty\n    values ('30765', 'Green', 'Music')\nThen we see that a new tuple has been inserted into instructor with salary set to null:\n\nselect *\nfrom instructor i \nwhere dept_name = 'Music'\n\n\n2 records\n\n\nid\nname\ndept_name\nsalary\n\n\n\n\n15151\nMozart\nMusic\n40000\n\n\n30765\nGreen\nMusic\nNA\n\n\n\n\n\nBut in case we define a view listing ID, name and building name of instructors:\ncreate view instructor_info as\nselect i.id, i.\"name\" , d.building \nfrom instructor i , department d \nwhere i.dept_name = d.name \nThis view is created by joining instuctor and department over the attributes instructor.dept_name and d.name. Trying to insert into this view raises and error along the lines of:\nSQL Error [55000]: ERROR: cannot insert into view \"instructor_info\"\nDetail: Views that do not select from a single table or view are not automatically updatable.\nA view is in general updatable:\n\nfrom clause has one DB relation.\nselect clause contains only attribute names of the relation and does not have\n\nexpressions\naggregates\ndistinct\n\nAttributes not listed in the select clause are not not null or primary key\nquery does not have a group by or having clause.\n\nSo, the view:\ncreate view history_instructors as\nselect *\nfrom instructor i \nwhere dept_name = 'History'\nwould be updatable:\ninsert into history_instructors \nvalues\n('14532', 'Roznicki', 'History', 57000)\n\n\n\n\n\n\nNote\n\n\n\nWe can still insert a non-history tuple to the history_instructors view:\ninsert into history_instructors\nvalues \n('10032', 'Nishimoto', 'Biology', 73120)\nThis tuple will be simply inserted into instructor relation and won’t appear in history_instructor:\n\nselect *\nfrom history_instructors \n\n\n3 records\n\n\nid\nname\ndept_name\nsalary\n\n\n\n\n32343\nEl Said\nHistory\n60000\n\n\n58583\nCalifieri\nHistory\n62000\n\n\n14532\nRoznicki\nHistory\n57000\n\n\n\n\n\n\nselect *\nfrom instructor\nwhere id = '10032'\n\n\n1 records\n\n\nid\nname\ndept_name\nsalary\n\n\n\n\n10032\nNishimoto\nBiology\n73120\n\n\n\n\n\n\n\nHowever views can be defined with a with check option clause at the end of the definition:\ncreate view biology_instructors as\nselect *\nfrom instructor i\nwhere i.dept_name = 'Biology'\nwith check option \nThen\ninsert into biology_instructors \nvalues \n('10311', 'Schmidt', 'Physics', 105000)\nWon’t be possible.\nPreferable altarnative to modifying views with default insert, update and delete is the instead of feature found in trigger declarations, that allow actions designed specifically for each case."
  },
  {
    "objectID": "notes/04interSQL/intersql.html#transactions",
    "href": "notes/04interSQL/intersql.html#transactions",
    "title": "14  Intermediate SQL",
    "section": "14.3 Transactions",
    "text": "14.3 Transactions\nTransaction is a sequence of query and/or update statements. A transaction begins implicitly when an sql statement is executed. One of follwoing statements must end a transaction:\n\ncommit [work]: The updates are made permanent. Afterwars transaction is automatically started.\nrollback [work]: undoes all the updates performed by during the transaction. DB is restored to the state before transaction started.\n\ncommit and rollback allow transactions to be atomic."
  },
  {
    "objectID": "notes/04interSQL/intersql.html#integrity-constraints",
    "href": "notes/04interSQL/intersql.html#integrity-constraints",
    "title": "14  Intermediate SQL",
    "section": "14.4 Integrity Constraints",
    "text": "14.4 Integrity Constraints\nExamples:\n\nInstructor name cannot be null\nDifferent instructors cannot have the same ID (primary key)\nEvery department name in course relation must have matching name in the department relation (referential integrity)\nThe budget of a department must be greater than $0,0\n\nIn general arbitrary predicates (that can be realistically tested by the DBMS).\nUsually part of the create table command but can also be added to an existing relation with alter table R add &lt;constraint&gt;\n\n14.4.1 Constraints on a Single Relation\ncreate table may include integrity-constraint statements in addition to primary key and foreign key:\n\nnot null\nunique\ncheck (&lt;predicate&gt;)\n\n\n\n14.4.2 Not Null\nRemember that null value is a member of all domains, therefore it is a legal value for every attribute in SQL by default, but it may me inapropriate for some attributes s.a.:\n\nstudent name\ndepartment budget\n\ndeclared as follows:\nname varchar(20) not null;\nbudget numeric(12, 2) not null \nThis prohibits insertion of a null value and is an example of a domain constraint. Primary keys are implicitly not null.\n\n\n14.4.3 Unique\nsql supports the integrity constraint:\nunique(a1, ..., a_n)\nwhich specifies that attributs a1, ..., a_n form a superkey. However they are allowed to be null unless explicitly declared not null.\n\n\n14.4.4 Check Clause\nIn a relation declaration check (&lt;Predicate&gt;) specified that &lt;Predicate&gt; must be satisfied by every tuple in the relation, which creates a powerful type system.\nExmaples:\n\ncheck(budget &gt; 0) in the declaration of department:\nvalues semester attribute can take in the declaration of section:\n\n  create table section(\n    course_id varchar(8),\n    sec_id varchar(8),\n    semester varchar(6),\n    year numeric(4, 0),\n    building varchar(15),\n    room_number varchar(7),\n    time_slot_id varchar(4),\n    primary key (course_id, sec_id, semester, year),\n    check( semester in ('Fall', 'Winter', 'Spring', 'Summer'))\n  )\n\n\n\n\n\n\nNote\n\n\n\nIn the above declaration if semester value is null it still does not violate the check condition, eventhough null is not one of specified values, because a check condition is violated only if it explicitly evaluates to false. unknown does not violate the check condition (comparisons with null). In order the avoid nulls not null must be explicitly specified.\n\n\ncheck() can be placed anywhere in the declaration. Often it is placed right after the attribute , if it effects a single attribute. More complex check() clauses are listed at the end of the declaration.\nAccording to the SQL standard arbitrary predicates and subqueries are allowed in check. But none of the current DBMS support subqueries.\nFurther check() examples:\n\ncourse:\n\ncreate table course (\n    ...\n    credits numeric(2, 0) check (credits &gt; 0) -- credit is numeric with two digits, must \n                                              -- be greater than 0\n)\n\ninstructor:\n\ncreate table instructor (\n    ...\n    salary numeric(8, 2) check (salary &gt; 29000) -- salary less than $1 mil, greater than $29k\n)\n\n\n14.4.5 Referential Integrity\nReferential Integrity: Often it is needed that a value that appears in a referencing relation for a given set of attributes also appears in a referenced relation.\nForeign keys is an example of a referential integrity constraint, reminder:\nforeign key (dept_name) references department --part of create table course (...)\nFor each tuple in course, value of dept_name must appear in name in department relation.\nBy default foreing-key references the primary-key attributes of the referenced relation but a list of attributes of the referenced relation can be specified explicitly. This list of attributes must either be primary key or unique:\nforeign key (dept_name) references department(name)\n\n\n\n\n\n\nNote\n\n\n\nMore general referential integrity, where referenced attributes do not form a candiate key is not supported by SQL. But there are alternative construct in SQL that can achieve this, eventhough none of them are supported by current SQL DBMS implementations.\n\n\nForeign key must reference a compatible set of attributes. (Cardinality and data type/domain)\n\n14.4.5.1 Cascade\nDefault behaviour is to reject a transaction that violates a referential integriy constraint. But this can changed with cascade.\nWith cascade instead of rejecting a delete or update that violates the constraint, the tuple in the referencing relation is changed. (updated or deleted)\nFor example in course relation\ncreate table course(\n    ...\n    foreign key (dept_name) references departments\n        on delete cascade\n        on update cascade,\n    ...\n)\n\non delete cascade: If a tuple in department is deleted, all tuples in the course that reference that department are deleteded\non update cascade: same as above\n\nfurther behaviour is allowed in SQL other than on delete cascade\n\non delete set null\non delete set default: set to the default value of the domain.\n\nForeign keys are allowed to be null, unless explicitly specified not null. By default foreign key values that contain a null are automatically accepted to satisfy the foreign-key contraint by default.\n\n\n\n14.4.6 Naming Constraints\nIntegrity constraints can be named explicitly with the keyword constraint:\nsalary numeric(8, 2), constraint minsalary check(salary &gt; 29000)\nThis allows dropping constraints by name:\nalter table instructor drop constraint minsalary\n\n\n14.4.7 Complex Checks and Assertions\nComplex conditions in checks are not implemented in practical DBMS’s, but are part of SQL:\ncheck (time_slot_id in (select id from time_slot)) -- in the definition of section\nCurrent DBMS’ do not provide create assertion or complex check constructs. Nevertheless, equivalent functionality can be achieved using triggers, including non-foreigh-key referential integrity constraints.\nAssertion is a predicate that a DB should always satsify. Consider:\n\nfor each student tuple in the student relation, tot_cred must be equal to the sum of successfully completed courses in the relation takes\n\ncreate assertion credits_earned_constraint check\n(not exists (\n    select id \n    from student s\n    where tot_cred &lt;&gt; (\n        select coalesce(sum(credits), 0)\n        from takes t, course c \n        where t.course_id = c.id \n            and s.id = takes.student_id\n            and t.grade is not null and t.grade &lt;&gt; 'F'\n    )\n))\nGeneral form of an SQL assertion:\ncreate assertion &lt;assertion-name&gt; check &lt;predicate&gt;\n\n\n\n\n\n\nNote\n\n\n\nSQL does not provide\n\\[\\forall x P(x)\\]\nInstead we use the equivalent\n\\[\\neg \\exists x \\neg P(x)\\]\nwhich in turn can be expressed as\n...\nwhere not exists (\n    ... -- SFW construct simulating tuples satifsying not P\n)\n..."
  },
  {
    "objectID": "notes/04interSQL/intersql.html#sql-data-types-and-schemas",
    "href": "notes/04interSQL/intersql.html#sql-data-types-and-schemas",
    "title": "14  Intermediate SQL",
    "section": "14.5 SQL Data Types and Schemas",
    "text": "14.5 SQL Data Types and Schemas\nWe covered basic DT, s.a. :\n\nint\nvarchar(&lt;N&gt;)\nnumeric(&lt;N&gt;, &lt;M&gt;)\nfloat\n\nThere are additional DTs, as well as possiblity to define custom DTs.\n\n14.5.1 Date and Time\nSQL standard supports several DTs relating to the dates and times:\n\ndate: A calendar date containing a four-digit year, month and a day of the month\ntime: The time of day in hours, minutes and seconds.\ntime(&lt;P&gt;): Same as time, where &lt;P&gt; can be used to specify the number of fractional digits for seconds.\ntime with timezone: Same as time, with the additional information for the time zone.\ntimestamp: A combination of time and date\ntimestamp(&lt;P&gt;): Same as timestamp, where &lt;P&gt; specifies the number of fractional digits for seconds. (default is 6)\ntimestamp with timezone: self-explanatory\n\nExmaples:\n\ndate '2023-04-25', format: yyyy-mm-dd\ntime '09:30:15', format: hh:mm:ss[.ff]\ntimestampt, format: date time\n\nIndividual fields can be extracted from date or time values using extract() function:\n\nvalues \n(extract(year from date('1999-12-12'))),\n(extract (second from time '10:15:30.14'))\n\n\n2 records\n\n\ncolumn1\n\n\n\n\n1999.00\n\n\n30.14\n\n\n\n\n\nWe can get current date, current time (with time zone), local time (without timezone), current time stamp (with time zone), local time stamp (without time zone):\n\nvalues\n(current_date) \n\n\n1 records\n\n\ncolumn1\n\n\n\n\n2023-10-29\n\n\n\n\n\n\nselect *\nfrom (\n    values \n    (current_time(2), localtime(2))\n) times(with_time_zone, without_time_zone)\n\n\n1 records\n\n\nwith_time_zone\nwithout_time_zone\n\n\n\n\n21:11:29.57\n21:11:29.57\n\n\n\n\n\n\nselect *\nfrom (\n    values \n    (current_timestamp, localtimestamp)\n) time_date(with_time_zone, without_time_zone)\n\n\n1 records\n\n\nwith_time_zone\nwithout_time_zone\n\n\n\n\n2023-10-29 21:11:29\n2023-10-29 21:11:29\n\n\n\n\n\nSQL allows comparison of date and time types.\nThere is interval data type that corresponds to interval compoutations of time types.\n\nvalues \n('10:30:15'::time - '09:15:30'::time)\n\n\n1 records\n\n\ncolumn1\n\n\n\n\n01:14:45\n\n\n\n\n\n\nvalues \n(age('1999-10-13'::date, '1983-03-15'::date))\n\n\n1 records\n\n\ncolumn1\n\n\n\n\n16 years 6 mons 29 days\n\n\n\n\n\nArithmetic operations with interval type are possible:\n\nvalues\n('1 years 5 mons 20 days'::interval + current_date)\n\n\n1 records\n\n\ncolumn1\n\n\n\n\n2025-04-18\n\n\n\n\n\n\n\n14.5.2 Type Conversion and Formatting Functions\n\n14.5.2.1 Casting\nCasting DT with cast(&lt;D1&gt; as &lt;D2&gt;) or with :::\n\nvalues \n(cast(10.2 as int)),\n(10.2::int),\n('1111'::int) --casting string as int\n\n\n3 records\n\n\ncolumn1\n\n\n\n\n10\n\n\n10\n\n\n1111\n\n\n\n\n\n\n\n14.5.2.2 Formatting\nChanging displayed format instead of the DT with to_char, to_number, to_date\n\nvalues \n(cast(10.2 as int)),\n(10.2::int),\n('1111'::int) --casting string as int;\n\n\n3 records\n\n\ncolumn1\n\n\n\n\n10\n\n\n10\n\n\n1111\n\n\n\n\n\n\nvalues \n(to_char(10, '999D99')),\n(to_char(124.43::real, '999D9'));\n\n\n2 records\n\n\ncolumn1\n\n\n\n\n10,00\n\n\n124,4\n\n\n\n\n\n\nvalues\n(to_char(localtimestamp, 'HH12:MI:SS')),\n(to_char (interval '15h 2m 12s', 'HH24:MI:SS'));\n\n\n2 records\n\n\ncolumn1\n\n\n\n\n09:11:29\n\n\n15:02:12\n\n\n\n\n\n\nvalues\n(to_date('05 Dec 2000', 'DD Mon YYYY'));\n\n\n1 records\n\n\ncolumn1\n\n\n\n\n2000-12-05\n\n\n\n\n\n\n\n14.5.2.3 Handling Null Values\nWe can specify how null values should be displayed with coalesce():\n\nselect a, coalesce(b, 0) as b\nfrom (\n    values \n    (1, null),\n    (2, 3)\n) r(a, b)\n\n\n2 records\n\n\na\nb\n\n\n\n\n1\n0\n\n\n2\n3\n\n\n\n\n\n\n\n\n14.5.3 Default Values\nA Default value can be specified for an attribute in the create table statement:\ncreate table student (\n    id varchar(5),\n    name varchar(20) not null,\n    dept_name varchar(20),\n    tot_cred numeric(3, 0) default 0\n    primary key (id)\n)\nWhen a tuple is inserted into student, if no value provided for tot_cred its value is set to 0 by default:\ninsert into student(id, name, dept_name)\nvalues ('12789', 'Newman', 'Comp. Sci.')\n\n\n14.5.4 User-Defined Types\nTwo forms are supported:\n\ndistinct types\nstructured data types: complex data types with nested record strutures, arrays and multisets\n\n\n14.5.4.1 Distinct Types\nEven though student.name and department.name are both strings, they should be distinct on the conceptual level.\nOn a programming level assigning a human name to a department name is probably a programming error. Similarly comparing a monetary value in dollars to a monetary value in pounds is also probably a programming error. A good type system should detect such errors.\ncreate domain can be used to create new types:\ncreate domain dollars as numeric(12, 2) check (value &gt;= 0)\nNew types can be used in create table declarations:\ncreate table department(\n    dept_name varchar(20),\n    building varchar(15),\n    budget Dollars\n)\n\n\n\n14.5.5 Generating Unique Key Values\nDBMS offer automatic management of unique-key value generation. In the instructor instead of\nid varchar(5)\nwe can write:\nid number(5) generated always as identiy\nAny insert statement must avoid specifying a value for the automatically generated key:\ninsert into instructor(name, dept_name, salary)\n    values ('Newprof', 'Comp. Sci.', 100000)\nif we replace always with by default we can specify own keys.\n\n\n14.5.6 Create Table Extensions\nCreating a table with the same schema as an existing table:\ncreate table temp_instructor (like instructor including all)\nA new table can be created and populated with data using a query:\ncreate table t1 as (\n    select i.name as i_name, i.salary as i_salary\n    from instructor i\n    where dept_name = 'Music'\n)\nwith data; --optional in postgres\n\n\n\n\n\n\nNote\n\n\n\ndifference to views:\n\nviews reflect the actual contents dynamically.\ntables created with the above method are initiated with set values."
  },
  {
    "objectID": "notes/04interSQL/intersql.html#index-definition-in-sql",
    "href": "notes/04interSQL/intersql.html#index-definition-in-sql",
    "title": "14  Intermediate SQL",
    "section": "14.6 Index Definition in SQL",
    "text": "14.6 Index Definition in SQL\nMany queries reference only a small portion of the records in the file:\n\nFind all instructors in the Physics department\nFind the salary of the instructor with the ID 22201\n\nreference only a fraction of the records in the instructor relation. It is inefficient to check every record if building field is ‘Physics’ or if id field is ‘22201’.\nAn index on an attribute of a relation is a data structure that allows the DBS to find those tuples in the relation that have a specified value for that attribute efficiently (in logarithmic time), without linearly scanning through all tuples of the relation.\nFor example, if we create an index on the dept_value attribute of the relation instructor, DBS can find records that have any specified value for dept_value s.a. “Physics”, or “Music” directly, without reading all the tuples linearly.\nAn index can also be created on a list of attributes instead of a single attribute, e.g. on name and dept_name of instructor.\nIndexes can be created automatically by the DBMS, but it is not easy to decide, therefore SQL DDL provides syntax for creating indexes manually with the create index command:\ncreate index &lt;index-name&gt; on &lt;relation-name&gt; (&lt;attribute-list&gt;);\nExample:\ncreate index dept_index on instructor (dept_name);\nNow, when a query uses dept_name from instructor it will benefit from the index and it will execute faster:\n\nselect *\nfrom instructor\nwhere dept_name = 'Music'\n\n\n2 records\n\n\nid\nname\ndept_name\nsalary\n\n\n\n\n15151\nMozart\nMusic\n40000\n\n\n30765\nGreen\nMusic\nNA\n\n\n\n\n\nNamed indexes can be dropped:\ndrop index dept_index;"
  },
  {
    "objectID": "notes/04interSQL/intersql.html#authorization",
    "href": "notes/04interSQL/intersql.html#authorization",
    "title": "14  Intermediate SQL",
    "section": "14.7 Authorization",
    "text": "14.7 Authorization\nA user ma be assigned several types of authorizations on parts of the DB:\n\nto read data\nto insert new data\nto update data\nto delete data\n\nEach of the above is called a privilege. A user may be authorized on combinations of those on parts of the DB such relations or views.\nUser may also be authorized on the DB Schema, s.a. create, modify or drop relations.\nA user may be authorized to\n\npass his authorization (grant)\nwithdraw an authorization that was granted (revoke)\n\n\n14.7.1 Granting and Revoking Privileges\nSQL includes following privileges:\n\nselect (reading data)\ninsert (insert new data)\nupdate (updating data)\ndelete (deleting data)\n\ngrant statement is used to confer authorization:\ngrant &lt;privilege list&gt;\non &lt;relation/view name&gt;\nto &lt;user/role list&gt;\nGrant read authorization department relation to users Amit and Satoshi\ngrant select on deparment to Amit, Satoshi\nUpdate authorization can be granted on the whole tuple or only on a list of attributes. List of attributes on which update authorization is granted appears after update listed inside parantheses\nGrant update authorization on budget attribute of the department relation to users Amit and Satoshi:\ngrant update on department(update) to Amit, Satoshi\ninsert and delete authorizations are analogous.\n\n\n\n\n\n\nNote\n\n\n\nThe user name public refers to all current and future users of the system. Thus privileges granted to public are implicitly granted to all current and future users.\n\n\nTo revoke authorizations revoke statement is used:\nrevoke select on department from Amit, Satoshi;\nrevoke update (budget) on department from Amit, Satoshi;\n\n\n14.7.2 Roles\nNaturally each instructor must have the same authorizations on same relations/views. When new insturctor is appointed they must automatically receive this roles.\nIn UniDB example roles could be:\n\ninstructor\nteaching_assistant\nstudent\ndean\ndepartment_chair\n\nRoles can be created as:\ncreate role instructor\nRoles can be granted priviliges just like users:\ngrant select on takes\nto instructor;\nRoles can be granted to users and to other roles:\ncreate role dean;\ngrant instructor to dean --grant role instructor to role dean\ngrant dean to Satoshi; -- grant role dean to user Satoshi\nWhen a user logs in to the DBS, actions executed by the user have all the privileges granted directly to the user, as well ones granted to roles granted to the user.\n\n\n14.7.3 Authorization on Views\nConsider a staff member who needs to know that salaries of all faculty in the Geology department, but is not authorized to see any information regarding other departments. Thus he must be denied direct access to the instructor relation, but still be able to see information from the Geology department. This can be achieved with granted authorization to a view:\ncreate view geo_instructor as (\n    select *\n    from instructor\n    where dept_name = 'Geology'\n)\nThen we can create role geo_admin and grant it certain privileges:\ncreate role geo_admin;\ngrant select on geo_instructor to geo_admin;\ngrant update (salary) on geo_instructor to geo_admin;\nThe user who creates this view must have select authorization on instructor relation.\n\n\n14.7.4 Transfer of Privileges\nA user/role is by default not allowd to pass on their authorization to other users/roles. This can be changed with with grant option clause.\nExample:\n\nWe wish to allow Amit select privilege on department and allow Amit to grant it to others:\n\ngrant select on department to Amit with grant option;\nConsider the granting of update authorization on the teaches relation. Assume that, initially DB admin grants update authorization to \\(U_1\\), \\(U_2\\), and \\(U_3\\), with with grant option. These users may grant this authorization to other users, which can be represented by an authorization graph.\nA user has an authorization iff there is path from root to the user.\n\n\n\nFigure 14.1: authorization-graph\n\n\n\n\n14.7.5 Revoking of Privileges\nSuppose DB admin decides to revoke the authorization of \\(U_1\\) show in Figure 14.1. Since \\(U_4\\) has received authorization from \\(U_1\\), his authorization should be revoked as well. However \\(U_5\\) was granted authorization by both \\(U_1\\) and \\(U_2\\). Since \\(U_2\\)s authorization was not revoked \\(U_5\\) retains the authorization.\nThis default behavior is cascading revokation. It can be prevented by the keyword restrict:\nrevoke select on department from Amit, Satoshi restrict\nThis revocation fails, if there are any cascading effects.\nOnly the privilege of granting an authorization can be revoked specifically:\nrevoke grant option for select on department from Amit;\nNow Amit can no more grant select privilege to other users, but still has the privilege itself.\nThe default cascading revokation is not appropriate in many cases. Suppose Sutoshi has the role dean, grants instructor to Amit, and later dean is revoked from Sutoshi, perhaps because he leaves the University. Since Amit continues to be employed he should retain the instructor role.\nTo deal with this, SQL permits privilege to be granted by a role rather than by a user. SQL has a notion of the current role associated with a session. By default it is null. It can be set with\nset role role_name --role associated with the session\nTo grant a privilege with the grantor as the current session role, we add the clause\ngranted by current_role\nto the grant statement, provided current session role is not null."
  },
  {
    "objectID": "notes/UniDB/unidb.html#er-model",
    "href": "notes/UniDB/unidb.html#er-model",
    "title": "15  Uni DB",
    "section": "15.1 ER Model",
    "text": "15.1 ER Model"
  },
  {
    "objectID": "notes/UniDB/unidb.html#relational-model",
    "href": "notes/UniDB/unidb.html#relational-model",
    "title": "15  Uni DB",
    "section": "15.2 Relational Model",
    "text": "15.2 Relational Model\n\n\\(\\texttt{intstructor}(\\underline{\\texttt{ID}}, \\texttt{name}, \\texttt{dept\\_name}\\rightarrow \\texttt{department}, \\texttt{salary})\\)\n\\(\\textbf{\\texttt{course}}(\\underline{\\texttt{id}}, \\texttt{ title}, \\texttt{ dept\\_name} \\rightarrow \\texttt{ department}, \\texttt{ credits})\\)\n\\(\\textbf{\\texttt{prereq}}(\\underline{\\texttt{course\\_id} \\rightarrow \\texttt{ course}, \\texttt{ prereq\\_id} \\rightarrow \\texttt{ course}})\\)\n\\(\\textbf{\\texttt{department}}(\\underline{\\texttt{name}} , \\texttt{ building, } \\texttt{ budget})\\)\n\\(\\textbf{\\texttt{section}}(\\udl{\\texttt{course\\_id}, \\texttt{id}, \\texttt{ semester}, \\texttt{ year, }}(\\texttt{building}, \\texttt{ room\\_number}) \\rightarrow \\texttt{classroom}, \\texttt{ time\\_slot\\_id})\\)\n\\(\\textbf{\\texttt{teaches}}(\\udl{\\texttt{instructor\\_ID}\\rightarrow \\texttt{ instructor}, (\\texttt{ course\\_id, sec\\_id, semester, year}) \\rightarrow \\texttt{ section}})\\)\n\\(\\textbf{\\texttt{student}}(\\udl{\\texttt{ID}}, \\texttt{ name}, \\texttt{ dept\\_name}\\rightarrow \\texttt{ department}, \\texttt{ total\\_credit})\\)\n\\(\\textbf{\\texttt{takes}}(\\udl{\\texttt{student\\_ID} \\rightarrow \\texttt{student}, (\\texttt{course\\_id, section\\_id, semester, year}) \\rightarrow \\texttt{section}}, \\texttt{grade})\\)\n\\(\\textbf{\\texttt{advisor}}(\\udl{\\texttt{student\\_id} \\rightarrow \\texttt{ student}, \\texttt{ instructor\\_id} \\rightarrow \\texttt{ instructor}})\\)\n\\(\\textbf{\\texttt{classroom}}(\\udl{\\texttt{building, room\\_number}}, \\texttt{ capacity})\\)\n\\(\\textbf{\\texttt{time\\_slot}}(\\udl{\\texttt{id}, \\texttt{ day}, \\texttt{ start\\_time}}, \\texttt{ end\\_time})\\)"
  },
  {
    "objectID": "notes/UniDB/unidb.html#sql",
    "href": "notes/UniDB/unidb.html#sql",
    "title": "15  Uni DB",
    "section": "15.3 SQL",
    "text": "15.3 SQL\n\n15.3.1 DDL\n\nDefinitions:\n\ndrop table prereq;\ndrop table time_slot;\ndrop table advisor;\ndrop table takes;\ndrop table student;\ndrop table teaches;\ndrop table section;\ndrop table instructor;\ndrop table course;\ndrop table department;\ndrop table classroom;\n\n\ncreate table classroom\n    (building       varchar(15),\n     room_number        varchar(7),\n     capacity       numeric(4,0),\n     primary key (building, room_number)\n    );\n\ncreate table department\n    (name       varchar(20), \n     building       varchar(15), \n     budget             numeric(12,2) check (budget &gt; 0),\n     primary key (name)\n    );\n\ncreate table course\n    (id     varchar(8), \n     title          varchar(50), \n     dept_name      varchar(20),\n     credits        numeric(2,0) check (credits &gt; 0),\n     primary key (id),\n     foreign key (dept_name) references department (name)\n        on delete set null\n    );\n\ncreate table instructor\n    (ID         varchar(5), \n     name           varchar(20) not null, \n     dept_name      varchar(20), \n     salary         numeric(8,2) check (salary &gt; 29000),\n     primary key (ID),\n     foreign key (dept_name) references department (name)\n        on delete set null\n    );\n\ncreate table section\n    (course_id      varchar(8), \n         id         varchar(8),\n     semester       varchar(6)\n        check (semester in ('Fall', 'Winter', 'Spring', 'Summer')), \n     year           numeric(4,0) check (year &gt; 1701 and year &lt; 2100), \n     building       varchar(15),\n     room_number        varchar(7),\n     time_slot_id       varchar(4),\n     primary key (course_id, id, semester, year),\n     foreign key (course_id) references course (id)\n        on delete cascade,\n     foreign key (building, room_number) references classroom (building, room_number)\n        on delete set null\n    );\n\ncreate table teaches\n    (instructor_ID          varchar(5), \n     course_id      varchar(8),\n     sec_id         varchar(8), \n     semester       varchar(6),\n     year           numeric(4,0),\n     primary key (instructor_ID, course_id, sec_id, semester, year),\n     foreign key (course_id, sec_id, semester, year) references section (course_id, id, semester, year)\n        on delete cascade,\n     foreign key (instructor_ID) references instructor (ID)\n        on delete cascade\n    );\n\ncreate table student\n    (ID         varchar(5), \n     name           varchar(20) not null, \n     dept_name      varchar(20), \n     tot_cred       numeric(3,0) check (tot_cred &gt;= 0),\n     primary key (ID),\n     foreign key (dept_name) references department (name)\n        on delete set null\n    );\n\ncreate table takes\n    (student_ID         varchar(5), \n     course_id      varchar(8),\n     sec_id         varchar(8), \n     semester       varchar(6),\n     year           numeric(4,0),\n     grade              varchar(2),\n     primary key (student_ID, course_id, sec_id, semester, year),\n     foreign key (course_id, sec_id, semester, year) references section (course_id, id, semester, year)\n        on delete cascade,\n     foreign key (student_ID) references student (ID)\n        on delete cascade\n    );\n\ncreate table advisor\n    (student_ID         varchar(5),\n     instructor_ID          varchar(5),\n     primary key (student_ID),\n     foreign key (instructor_id) references instructor (ID)\n        on delete set null,\n     foreign key (student_ID) references student (ID)\n        on delete cascade\n    );\n\ncreate table time_slot\n    (id     varchar(4),\n     day            varchar(1),\n     start_hr       numeric(2) check (start_hr &gt;= 0 and start_hr &lt; 24),\n     start_min      numeric(2) check (start_min &gt;= 0 and start_min &lt; 60),\n     end_hr         numeric(2) check (end_hr &gt;= 0 and end_hr &lt; 24),\n     end_min        numeric(2) check (end_min &gt;= 0 and end_min &lt; 60),\n     primary key (id, day, start_hr, start_min)\n    );\n\ncreate table prereq\n    (course_id      varchar(8), \n     prereq_id      varchar(8),\n     primary key (course_id, prereq_id),\n     foreign key (course_id) references course (id)\n        on delete cascade,\n     foreign key (prereq_id) references course (id)\n    );\n\nData:\n\ndelete from prereq;\ndelete from time_slot;\ndelete from advisor;\ndelete from takes;\ndelete from student;\ndelete from teaches;\ndelete from section;\ndelete from instructor;\ndelete from course;\ndelete from department;\ndelete from classroom;\ninsert into classroom values ('Packard', '101', '500');\n...\ninsert into department values ('Biology', 'Watson', '90000');\n...\ninsert into course values ('BIO-101', 'Intro. to Biology', 'Biology', '4');\n...\ninsert into instructor values ('10101', 'Srinivasan', 'Comp. Sci.', '65000');\n...\ninsert into section values ('BIO-101', '1', 'Summer', '2017', 'Painter', '514', 'B');\n...\ninsert into teaches values ('10101', 'CS-101', '1', 'Fall', '2017');\n...\ninsert into student values ('00128', 'Zhang', 'Comp. Sci.', '102');\n...\ninsert into takes values ('00128', 'CS-101', '1', 'Fall', '2017', 'A');\n...\ninsert into advisor values ('00128', '45565');\n...\ninsert into time_slot values ('A', 'M', '8', '0', '8', '50');\n...\ninsert into prereq values ('BIO-301', 'BIO-101');\n...\n\n\n15.3.2 Example Querries"
  }
]